<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>作る - あまりにも超大量の連結リストで学ぶRust</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Learning Rust With Entirely Too Many Linked Lists">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="index.html"><strong aria-hidden="true">1.</strong> はじめに</a></li><li><a href="first.html"><strong aria-hidden="true">2.</strong> クソスタック</a></li><li><ol class="section"><li><a href="first-layout.html"><strong aria-hidden="true">2.1.</strong> 設計</a></li><li><a href="first-new.html"><strong aria-hidden="true">2.2.</strong> New</a></li><li><a href="first-ownership.html"><strong aria-hidden="true">2.3.</strong> 所有権</a></li><li><a href="first-push.html"><strong aria-hidden="true">2.4.</strong> Push</a></li><li><a href="first-pop.html"><strong aria-hidden="true">2.5.</strong> Pop</a></li><li><a href="first-test.html"><strong aria-hidden="true">2.6.</strong> テスト</a></li><li><a href="first-drop.html"><strong aria-hidden="true">2.7.</strong> Drop</a></li><li><a href="first-final.html"><strong aria-hidden="true">2.8.</strong> 最終コード</a></li></ol></li><li><a href="second.html"><strong aria-hidden="true">3.</strong> まあまあなスタック</a></li><li><ol class="section"><li><a href="second-option.html"><strong aria-hidden="true">3.1.</strong> Option</a></li><li><a href="second-generic.html"><strong aria-hidden="true">3.2.</strong> ジェネリクス</a></li><li><a href="second-peek.html"><strong aria-hidden="true">3.3.</strong> Peek</a></li><li><a href="second-into-iter.html"><strong aria-hidden="true">3.4.</strong> IntoIter</a></li><li><a href="second-iter.html"><strong aria-hidden="true">3.5.</strong> Iter</a></li><li><a href="second-iter-mut.html"><strong aria-hidden="true">3.6.</strong> IterMut</a></li><li><a href="second-final.html"><strong aria-hidden="true">3.7.</strong> 最終コード</a></li></ol></li><li><a href="third.html"><strong aria-hidden="true">4.</strong> 永続スタック</a></li><li><ol class="section"><li><a href="third-layout.html"><strong aria-hidden="true">4.1.</strong> 設計</a></li><li><a href="third-basics.html"><strong aria-hidden="true">4.2.</strong> 基本</a></li><li><a href="third-drop.html"><strong aria-hidden="true">4.3.</strong> Drop</a></li><li><a href="third-arc.html"><strong aria-hidden="true">4.4.</strong> Arc</a></li><li><a href="third-final.html"><strong aria-hidden="true">4.5.</strong> 最終コード</a></li></ol></li><li><a href="fourth.html"><strong aria-hidden="true">5.</strong> メモリ安全クソ両端キュー</a></li><li><ol class="section"><li><a href="fourth-layout.html"><strong aria-hidden="true">5.1.</strong> 設計</a></li><li><a href="fourth-building.html" class="active"><strong aria-hidden="true">5.2.</strong> 作る</a></li><li><a href="fourth-breaking.html"><strong aria-hidden="true">5.3.</strong> 崩す</a></li><li><a href="fourth-peek.html"><strong aria-hidden="true">5.4.</strong> Peek</a></li><li><a href="fourth-symmetry.html"><strong aria-hidden="true">5.5.</strong> 対称的な操作の実装</a></li><li><a href="fourth-iteration.html"><strong aria-hidden="true">5.6.</strong> イテレート</a></li><li><a href="fourth-final.html"><strong aria-hidden="true">5.7.</strong> 最終コード</a></li></ol></li><li><a href="fifth.html"><strong aria-hidden="true">6.</strong> メモリ不安全キュー</a></li><li><ol class="section"><li><a href="fifth-layout.html"><strong aria-hidden="true">6.1.</strong> 設計</a></li><li><a href="fifth-unsafe.html"><strong aria-hidden="true">6.2.</strong> Unsafe</a></li><li><a href="fifth-basics.html"><strong aria-hidden="true">6.3.</strong> 基本</a></li><li><a href="fifth-extras.html"><strong aria-hidden="true">6.4.</strong> 応用</a></li><li><a href="fifth-final.html"><strong aria-hidden="true">6.5.</strong> 最終コード</a></li></ol></li><li><a href="sixth.html"><strong aria-hidden="true">7.</strong> まあまあなメモリ不安全両端キュー</a></li><li><a href="infinity.html"><strong aria-hidden="true">8.</strong> アホなリストたち</a></li><li><ol class="section"><li><a href="infinity-double-single.html"><strong aria-hidden="true">8.1.</strong> 二重片方向リスト</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">あまりにも超大量の連結リストで学ぶRust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#作る" id="作る">作る</a></h1>
<p>ではリストを作る処理からやっていきましょう．これは素直に実装できます．
<code>new</code>は相変わらず簡単で，単にNoneで埋めればいいだけです．ちょっと扱いにくく
なりつつあるのでNodeのコンストラクタも作ってしまいましょう：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Node&lt;T&gt; {
    fn new(elem: T) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {
        Rc::new(RefCell::new(Node {
            elem: elem,
            prev: None,
            next: None,
        }))
    }
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

**A BUNCH OF DEAD CODE WARNINGS BUT IT BUILT**
</code></pre>
<p>いえーい！</p>
<p>今度はリストの先頭に要素をpushする操作を書きましょう．双方向リストは
明らかに単方向リストより複雑なのでちょっと手間をかける必要があります．
単方向リストのときは関数を1行にすることもできましたが今回はそうは
いきません．</p>
<p>とくにリストが空の場合の境界条件に対処する必要があります．大抵の処理は
<code>head</code>と<code>tail</code>のどちらかのポインタを操作するだけでいいのですが，空リスト
がからむと<em>両方</em>を同時に操作する必要があります．</p>
<p>メソッドが機能しているかどうかチェックするには「それぞれのノードを指すポインタが
2つずつある」状態を保っているかを見ると簡単です．リストの間にあるノードは
1つ前と1つ後からのポインタがあり，リストの端のノードは片方がリスト自体からの
ポインタになりますよね．</p>
<p>やってみましょう：</p>
<pre><code class="language-rust ignore">pub fn push_front(&amp;mut self, elem: T) {
    // 新しいノードはリンクの個数が+2され，他は+0であればよい
    let new_head = Node::new(elem);
    match self.head.take() {
        Some(old_head) =&gt; {
            // 空でないリストなのでold_headをつなげる
            old_head.prev = Some(new_head.clone()); // +1 new_head
            new_head.next = Some(old_head);         // +1 old_head
            self.head = Some(new_head);             // +1 new_head, -1 old_head
            // 計：+2 new_head, +0 old_head -- OK!
        }
        None =&gt; {
            // 空リストなのでtailにセットする
            self.tail = Some(new_head.clone());     // +1 new_head
            self.head = Some(new_head);             // +1 new_head
            // 計：+2 new_head -- OK!
        }
    }
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0609]: no field `prev` on type `std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;`
  --&gt; src/fourth.rs:39:26
   |
39 |                 old_head.prev = Some(new_head.clone()); // +1 new_head
   |                          ^^^^ unknown field

error[E0609]: no field `next` on type `std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;`
  --&gt; src/fourth.rs:40:26
   |
40 |                 new_head.next = Some(old_head);         // +1 old_head
   |                          ^^^^ unknown field
</code></pre>
<p>はいはい，コンパイルエラーね．まずはね．まずは．</p>
<p>なんで<code>prev</code>と<code>next</code>を見れないのでしょうか？<code>Rc&lt;Node&gt;</code>だったときには動いていたので
<code>RefCell</code>が邪魔してそうです．</p>
<p>ドキュメントを見てみるのがいいでしょう．</p>
<p><em>&quot;rust refcell&quot;でググる</em></p>
<p><em><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">最初のリンクをクリック</a></em></p>
<blockquote>
<p>A mutable memory location with dynamically checked borrow rules</p>
<p>See the <a href="https://doc.rust-lang.org/std/cell/index.html">module-level documentation</a> for more.</p>
</blockquote>
<p><em>リンクをクリック</em></p>
<blockquote>
<p>Shareable mutable containers.</p>
<p>Values of the <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> types may be mutated through shared references (i.e.
the common <code>&amp;T</code> type), whereas most Rust types can only be mutated through unique (<code>&amp;mut T</code>)
references. We say that <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> provide 'interior mutability', in contrast
with typical Rust types that exhibit 'inherited mutability'.</p>
<p>Cell types come in two flavors: <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>. <code>Cell&lt;T&gt;</code> provides <code>get</code> and <code>set</code>
methods that change the interior value with a single method call. <code>Cell&lt;T&gt;</code> though is only
compatible with types that implement <code>Copy</code>. For other types, one must use the <code>RefCell&lt;T&gt;</code>
type, acquiring a write lock before mutating.</p>
<p><code>RefCell&lt;T&gt;</code> uses Rust's lifetimes to implement 'dynamic borrowing', a process whereby one can
claim temporary, exclusive, mutable access to the inner value. Borrows for <code>RefCell&lt;T&gt;</code>s are
tracked 'at runtime', unlike Rust's native reference types which are entirely tracked
statically, at compile time. Because <code>RefCell&lt;T&gt;</code> borrows are dynamic it is possible to attempt
to borrow a value that is already mutably borrowed; when this happens it results in thread
panic.</p>
<h1><a class="header" href="#when-to-choose-interior-mutability" id="when-to-choose-interior-mutability">When to choose interior mutability</a></h1>
<p>The more common inherited mutability, where one must have unique access to mutate a value, is
one of the key language elements that enables Rust to reason strongly about pointer aliasing,
statically preventing crash bugs. Because of that, inherited mutability is preferred, and
interior mutability is something of a last resort. Since cell types enable mutation where it
would otherwise be disallowed though, there are occasions when interior mutability might be
appropriate, or even <em>must</em> be used, e.g.</p>
<ul>
<li>Introducing inherited mutability roots to shared types.</li>
<li>Implementation details of logically-immutable methods.</li>
<li>Mutating implementations of <code>Clone</code>.</li>
</ul>
<h2><a class="header" href="#introducing-inherited-mutability-roots-to-shared-types" id="introducing-inherited-mutability-roots-to-shared-types">Introducing inherited mutability roots to shared types</a></h2>
<p>Shared smart pointer types, including <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>, provide containers that can be
cloned and shared between multiple parties. Because the contained values may be
multiply-aliased, they can only be borrowed as shared references, not mutable references.
Without cells it would be impossible to mutate data inside of shared boxes at all!</p>
<p>It's very common then to put a <code>RefCell&lt;T&gt;</code> inside shared pointer types to reintroduce
mutability:</p>
<pre><code class="language-rust ignore">use std::collections::HashMap;
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let shared_map: Rc&lt;RefCell&lt;_&gt;&gt; = Rc::new(RefCell::new(HashMap::new()));
    shared_map.borrow_mut().insert(&quot;africa&quot;, 92388);
    shared_map.borrow_mut().insert(&quot;kyoto&quot;, 11837);
    shared_map.borrow_mut().insert(&quot;piccadilly&quot;, 11826);
    shared_map.borrow_mut().insert(&quot;marbles&quot;, 38);
}
</code></pre>
<p>Note that this example uses <code>Rc&lt;T&gt;</code> and not <code>Arc&lt;T&gt;</code>. <code>RefCell&lt;T&gt;</code>s are for single-threaded
scenarios. Consider using <code>Mutex&lt;T&gt;</code> if you need shared mutability in a multi-threaded
situation.</p>
<p>（訳）</p>
<p>共有可能な可変コンテナ．</p>
<p>一般的なRustの型は可変参照（<code>&amp;mut T</code>）を通してしか変更できませんが，<code>Cell&lt;T&gt;</code>型と<code>RefCell&lt;T&gt;</code>型
の値は共有参照（<code>&amp;T</code>）を通して変更される可能性があります．このことをもって<code>Cell&lt;T&gt;</code>と<code>RefCell&lt;T&gt;</code>
は「内部可変性」を持つと言います．これは他の普通の型が「継承可変性」を持つことと対照的です．</p>
<p>Cell型には<code>Cell&lt;T&gt;</code>と<code>RefCell&lt;T&gt;</code>の2種類があります．<code>Cell&lt;T&gt;</code>には内部の値を操作するための<code>get</code>
と<code>set</code>メソッドがあります．しかし<code>Cell&lt;T&gt;</code>は<code>Copy</code>を実装する型に対してしか機能しません．他の
型に対しては<code>RefCell&lt;T&gt;</code>を使用することで変更する前に書き込みロックを獲得する必要があります．</p>
<p><code>RefCell&lt;T&gt;</code>はRustのライフタイムを「動的借用」を実現するために使っています．動的借用とは一時的
かつ排他的な可変参照を得るための手段です．通常のRustの借用がコンパイル時に静的にチェックされる
のと違い，<code>RefCell&lt;T&gt;</code>による借用はランタイムにチェックされます．<code>RefCell&lt;T&gt;</code>の借用は動的であり，
実際には排他的でない可変な借用が発生する可能性があるからです．もしそうなったときはスレッドが
パニックします．</p>
<h1><a class="header" href="#どんなときに内部可変性を使うべきか" id="どんなときに内部可変性を使うべきか">どんなときに内部可変性を使うべきか</a></h1>
<p>値を変更するために排他的なアクセスを要求する継承可変性はRustの重要な言語機能の一つであり，
それによってポインタエイリアスを推論したりクラッシュバグを防いだりすることができています．
それゆえ継承可変性のほうが好まれ，内部可変性は最後の手段のようなものです．しかしCell型が
普通ではできない値の変更を行えるため，内部可変性がふさわしい，もしくは必要である場合が
あります．例えば次のようなときです．</p>
<ul>
<li>共有された型に継承可変性を持ち込むとき．</li>
<li>論理的に不変なメソッドの実装を行うとき．</li>
<li><code>Clone</code>の実装を変えるとき．</li>
</ul>
<h2><a class="header" href="#共有された型に継承可変性を持ち込むとき" id="共有された型に継承可変性を持ち込むとき">共有された型に継承可変性を持ち込むとき</a></h2>
<p><code>Rc&lt;T&gt;</code>や<code>Arc&lt;T&gt;</code>のような共有スマートポインタ型は，内側の値を複数の部分から利用可能にします．
内部の値は共有されているため，可変参照ではなく共有参照しか取得できません．Cell型なしでは
これらの内部の値を変化させることは全くできないのです！</p>
<p>可変性を得るために<code>RefCell&lt;T&gt;</code>をスマートポインタ型に入れることはとても一般的です：</p>
<pre><code class="language-rust ignore">use std::collections::HashMap;
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let shared_map: Rc&lt;RefCell&lt;_&gt;&gt; = Rc::new(RefCell::new(HashMap::new()));
    shared_map.borrow_mut().insert(&quot;africa&quot;, 92388);
    shared_map.borrow_mut().insert(&quot;kyoto&quot;, 11837);
    shared_map.borrow_mut().insert(&quot;piccadilly&quot;, 11826);
    shared_map.borrow_mut().insert(&quot;marbles&quot;, 38);
}
</code></pre>
<p>この例では<code>Arc&lt;T&gt;</code>ではなく<code>Rc&lt;T&gt;</code>を使っていることに注目してください．<code>RefCell&lt;T&gt;</code>は
単一スレッドで動作します．もしマルチスレッドで共有可変性が欲しい場合<code>Mutex&lt;T&gt;</code>を使って
ください．</p>
</blockquote>
<p>いやー，Rustのドキュメントは相変わらずマジ最高ですね．</p>
<p>とくに注目したいのはここです：</p>
<pre><code class="language-rust ignore">shared_map.borrow_mut().insert(&quot;africa&quot;, 92388);
</code></pre>
<p>もっというと<code>borrow_mut</code>ってやつです．RefCellから借用するときは明示的に
やらなくてはいけないようです．<code>.</code>が勝手にやってくれないのは不思議な
仕様ですね．まあやってみましょう：</p>
<pre><code class="language-rust ignore">pub fn push_front(&amp;mut self, elem: T) {
    let new_head = Node::new(elem);
    match self.head.take() {
        Some(old_head) =&gt; {
            old_head.borrow_mut().prev = Some(new_head.clone());
            new_head.borrow_mut().next = Some(old_head);
            self.head = Some(new_head);
        }
        None =&gt; {
            self.tail = Some(new_head.clone());
            self.head = Some(new_head);
        }
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

warning: field is never used: `elem`
  --&gt; src/fourth.rs:12:5
   |
12 |     elem: T,
   |     ^^^^^^^
   |
   = note: #[warn(dead_code)] on by default
</code></pre>
<p>ビルドしましたよ！またドキュメント勝ちしました．</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="fourth-layout.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="fourth-breaking.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="fourth-layout.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="fourth-breaking.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
