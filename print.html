<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>あまりにも超大量の連結リストで学ぶRust</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Learning Rust With Entirely Too Many Linked Lists">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="index.html"><strong aria-hidden="true">1.</strong> はじめに</a></li><li><a href="first.html"><strong aria-hidden="true">2.</strong> クソスタック</a></li><li><ol class="section"><li><a href="first-layout.html"><strong aria-hidden="true">2.1.</strong> 設計</a></li><li><a href="first-new.html"><strong aria-hidden="true">2.2.</strong> New</a></li><li><a href="first-ownership.html"><strong aria-hidden="true">2.3.</strong> 所有権</a></li><li><a href="first-push.html"><strong aria-hidden="true">2.4.</strong> Push</a></li><li><a href="first-pop.html"><strong aria-hidden="true">2.5.</strong> Pop</a></li><li><a href="first-test.html"><strong aria-hidden="true">2.6.</strong> テスト</a></li><li><a href="first-drop.html"><strong aria-hidden="true">2.7.</strong> Drop</a></li><li><a href="first-final.html"><strong aria-hidden="true">2.8.</strong> 最終コード</a></li></ol></li><li><a href="second.html"><strong aria-hidden="true">3.</strong> まあまあなスタック</a></li><li><ol class="section"><li><a href="second-option.html"><strong aria-hidden="true">3.1.</strong> Option</a></li><li><a href="second-generic.html"><strong aria-hidden="true">3.2.</strong> ジェネリクス</a></li><li><a href="second-peek.html"><strong aria-hidden="true">3.3.</strong> Peek</a></li><li><a href="second-into-iter.html"><strong aria-hidden="true">3.4.</strong> IntoIter</a></li><li><a href="second-iter.html"><strong aria-hidden="true">3.5.</strong> Iter</a></li><li><a href="second-iter-mut.html"><strong aria-hidden="true">3.6.</strong> IterMut</a></li><li><a href="second-final.html"><strong aria-hidden="true">3.7.</strong> 最終コード</a></li></ol></li><li><a href="third.html"><strong aria-hidden="true">4.</strong> 永続スタック</a></li><li><ol class="section"><li><a href="third-layout.html"><strong aria-hidden="true">4.1.</strong> 設計</a></li><li><a href="third-basics.html"><strong aria-hidden="true">4.2.</strong> 基本</a></li><li><a href="third-drop.html"><strong aria-hidden="true">4.3.</strong> Drop</a></li><li><a href="third-arc.html"><strong aria-hidden="true">4.4.</strong> Arc</a></li><li><a href="third-final.html"><strong aria-hidden="true">4.5.</strong> 最終コード</a></li></ol></li><li><a href="fourth.html"><strong aria-hidden="true">5.</strong> メモリ安全クソ両端キュー</a></li><li><ol class="section"><li><a href="fourth-layout.html"><strong aria-hidden="true">5.1.</strong> 設計</a></li><li><a href="fourth-building.html"><strong aria-hidden="true">5.2.</strong> 作る</a></li><li><a href="fourth-breaking.html"><strong aria-hidden="true">5.3.</strong> 崩す</a></li><li><a href="fourth-peek.html"><strong aria-hidden="true">5.4.</strong> Peek</a></li><li><a href="fourth-symmetry.html"><strong aria-hidden="true">5.5.</strong> 対称的な操作の実装</a></li><li><a href="fourth-iteration.html"><strong aria-hidden="true">5.6.</strong> イテレート</a></li><li><a href="fourth-final.html"><strong aria-hidden="true">5.7.</strong> 最終コード</a></li></ol></li><li><a href="fifth.html"><strong aria-hidden="true">6.</strong> メモリ不安全キュー</a></li><li><ol class="section"><li><a href="fifth-layout.html"><strong aria-hidden="true">6.1.</strong> 設計</a></li><li><a href="fifth-unsafe.html"><strong aria-hidden="true">6.2.</strong> Unsafe</a></li><li><a href="fifth-basics.html"><strong aria-hidden="true">6.3.</strong> 基本</a></li><li><a href="fifth-extras.html"><strong aria-hidden="true">6.4.</strong> 応用</a></li><li><a href="fifth-final.html"><strong aria-hidden="true">6.5.</strong> 最終コード</a></li></ol></li><li><a href="sixth.html"><strong aria-hidden="true">7.</strong> まあまあなメモリ不安全両端キュー</a></li><li><a href="infinity.html"><strong aria-hidden="true">8.</strong> アホなリストたち</a></li><li><ol class="section"><li><a href="infinity-double-single.html"><strong aria-hidden="true">8.1.</strong> 二重片方向リスト</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">あまりにも超大量の連結リストで学ぶRust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#あまりにも超大量の連結リストで学ぶrust" id="あまりにも超大量の連結リストで学ぶrust">あまりにも超大量の連結リストで学ぶRust</a></h1>
<blockquote>
<p>困ったことがあったり，最終的なコードを全部見たいときは<a href="https://github.com/Gankro/too-many-lists">Githubを見てください！</a><br />
訳に関する文句などは<a href="https://github.com/misonomi/too-many-lists">こちら</a></p>
</blockquote>
<blockquote>
<p><strong>注意</strong>: この本は rustc 1.31 (Dec 8, 2018) でリリースされた Rust 2018 向けに
書かれています．もしあなたのRustツールチェインが十分に新しければ，<code>cargo new</code>
で作られた Cargo.toml ファイルは<code>edition = &quot;2018&quot;</code>という行を含んでいるはずです
（もしあなたが遠い未来にこれを読んでいるなら，もっと新しい数字かもしれません）．
古いツールチェインを使うこともできますが，秘密の<strong>ハードモード</strong>が解除され，
あなたはこの本に全く書かれていないコンパイルエラーに見舞われるでしょう．
楽しそうですね．</p>
</blockquote>
<p>私はよくRustでの連結リストの実装について質問を受けます．正直答えはあなたの要件に
よりますし，その場合ごとのちょうどいい答えを出すのは明らかに簡単ではありません．
そんなわけで，そういった質問に一発でまるっと答えられるようにこの本を書きました．</p>
<p>この本では，6つの連結リストの実装を通してRustのプログラミングを
基本から応用までお教えします．あなたはこんなことを学ぶでしょう：</p>
<ul>
<li>ポインタ型：<code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, <code>Rc</code>, <code>Arc</code>, <code>*const</code>, <code>*mut</code></li>
<li>所有権，借用，継承可変性，内部可変性，Copy</li>
<li>用語：struct, enum, fn, pub, impl, use, ...</li>
<li>パターンマッチング，ジェネリクス，デストラクタ</li>
<li>テスト</li>
<li>unsafeの基本</li>
</ul>
<p>そう，連結リストはこれ全部に触れなくては実装できないくらい本当に恐ろしい代物です．</p>
<p>サイドバーにありますが（モバイルデバイスで見ると畳まれてるかも），こういうものを
実装します：</p>
<ol>
<li><a href="first.html">クソ片方向スタック</a></li>
<li><a href="second.html">まあまあな片方向スタック</a></li>
<li><a href="third.html">永続片方向スタック</a></li>
<li><a href="fourth.html">クソだけどメモリ安全な両端キュー</a></li>
<li><a href="fifth.html">メモリ不安全な片方向キュー</a></li>
<li><a href="sixth.html">TODO: まあまあなメモリ不安全両端キュー</a></li>
<li><a href="infinity.html">おまけ: アホなリストたち</a></li>
</ol>
<p>皆さんがちゃんとついてこられるように，私がターミナルに入力するコマンドは全部
書いておきます．パッケージマネージャーもRust標準のCargoを使います．Cargoは
Rustを書くのに必要不可欠というわけではありませんが，rustcディレクトリを
使うより<em>かなり</em>いいです．ちょっとRustを試してみるくらいのつもりなら，
<a href="https://play.rust-lang.org/">play.rust-lang.org</a>でブラウザから簡単なコードを実行することもできます．</p>
<p>では手始めにプロジェクトを作りましょう:</p>
<pre><code class="language-text">&gt; cargo new --lib lists
&gt; cd lists
</code></pre>
<p>作ったものに上書きしてしまわないように，それぞれのリストを別々のファイルに作ります．</p>
<p><em>本物の</em>Rustの学習には，コードを書いて，コンパイラにクソ怒られて，それが何を
意味するかを解き明かそうとする体験がつきものです．私はそうした状況が
なるべく沢山起こるようにしました．Rustのコンパイラが出す（たいてい）有用な
エラーメッセージを読んで理解することは，能力あるRustプログラマになるために
<em>超</em>重要なことです．</p>
<p>...というのは実は嘘です．これを書く間，私はお見せするより<em>ずっと</em>たくさんの
コンパイルエラーにぶち当たりました．特に後ろの方の章ではどんな言語でも
あるようなタイプミス/コピペミスのエラーをいちいち見せていません．これは
コンパイラに怒られるコースをゆく<em>ガイド付きツアー</em>です．</p>
<p>このツアーはゆっくり進みます．そして，正直なところクソ真面目にやるつもりは
すこしもありません．プログラミングは楽しいものですよね，クソが！
もしあなたが冗長さを嫌う，まじめで格式高い方ならこの本はあなた向きではありません．
私が作る何もかもがあなた向きではありません．あなたの人生は間違っています．</p>
<h1><a class="header" href="#どうしても要る公共広告" id="どうしても要る公共広告">どうしても要る公共広告</a></h1>
<p>まず100%はっきりさせておきましょう．私は連結リストが大嫌いです．心の底から．
連結リストはマジでひどいデータ構造です．もちろん連結リストが有用な場合も
あります：</p>
<ul>
<li>長大なリストを<em>何回も</em>分割したりくっつけたりするとき．<em>何回も</em>．</li>
<li>めっちゃすごいLockしたりFreeしたりする同期処理をするとき．</li>
<li>侵入型<sup class="footnote-reference"><a href="#1">1</a></sup>リストを使ってカーネルや組み込み系を実装するとき．</li>
<li>純粋な関数型言語を使っていて，セマンティクスが限定されていて可変性がないので
連結リストが使いやすいとき．</li>
<li>... とか！</li>
</ul>
<p>でも上のような場合はRustを書く人にとっては<em>ごくまれ</em>です．99%の場合Vec（配列スタック）
でいいですし，残った1%のうちの99%はVecDeque（配列両端キュー）でいいです．Vecや
VecDequeはメモリ割当頻度が少なく，メモリオーバーヘッドが小さく，ランダムアクセス
ができ，キャッシュ局所性があり，明らかにより優れたデータ構造です．</p>
<p>連結リストはトライ木と同じくらいニッチなデータ構造です．トライ木がニッチじゃないと
言ってくる人はほとんどいないでしょう．あなたがエンジニアとしてやっていく分には
一生学ばなくてすむのですから．それにもかかわらず連結リストはなぜか優遇されています．
私達は学生達全員に連結リストの書き方を教えています．私はこいつだけを
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">std::collectionsから消し損ないました</a>．<a href="http://en.cppreference.com/w/cpp/container/list">C++ではリストといえばこいつ</a>です！</p>
<p>私達は団結して連結リストが標準的なデータ構造として扱われることに反対すべきです．
特定の状況ではいいデータ構造ですが，そういう状況は<em>例外的</em>で，誰もが遭遇する
わけではありません．</p>
<p>何人かの人はこの公共広告の１段落目で読むのをやめて，私が挙げた連結リストの
<em>素晴らしい</em>用法を持ち出して私に反論しようとするでしょう．それは次の段落に
書いてあるっての！</p>
<p>詳細な議論のために，私が今まで見た反論とそれに対する回答を書いておきます．
Rustを学びたい方は遠慮なく<a href="first.html">一章</a>へどうぞ！</p>
<h2><a class="header" href="#パフォーマンスがいつも重要なわけじゃないだろ" id="パフォーマンスがいつも重要なわけじゃないだろ">パフォーマンスがいつも重要なわけじゃないだろ</a></h2>
<p>そうですね！多分あなたのアプリケーションにI/O待ちがあるとか，とにかく関係ない
感じなんでしょう．でもそれは連結リストを使うかどうかという問題じゃないですよね．
それは<em>あらゆるもの</em>を使うかどうかという問題です．なんで連結リストを使うんですか？
連結ハッシュマップを使いましょう！</p>
<p>パフォーマンスが関係ないなら<em>もちろん</em>素の配列を使ってもいいはずです．</p>
<h2><a class="header" href="#ポインタを握ってればo1で分割して連結して挿入して削除できるじゃん" id="ポインタを握ってればo1で分割して連結して挿入して削除できるじゃん">ポインタを握ってればO(1)で分割して連結して挿入して削除できるじゃん</a></h2>
<p>はい！<a href="https://www.youtube.com/watch?v=YQs6IC-vgmo">Bjarne Stroustrup氏が書かれているように</a>，<em>これは実は
どうもいい</em>ことです．ポインタを取得する時間が配列の要素を全部コピーする
時間より大して速くない場合には．そして配列のコピーはかなり速いです．</p>
<p>分割・連結のコストがめちゃくちゃ大きくない限り，<em>他のあらゆる</em>操作が
キャッシュやコードの煩雑さによってダメダメになり，長所を消してしまいます．</p>
<p><em>でもそうですね，もしあなたのアプリケーションが配列の分割・連結に
大きな時間を使っているなら連結リストを使ううま味があるでしょう</em>．</p>
<h2><a class="header" href="#償却-sup-classfootnote-referencea-href22asup-する余裕ないんだけど" id="償却-sup-classfootnote-referencea-href22asup-する余裕ないんだけど">償却 <sup class="footnote-reference"><a href="#2">2</a></sup> する余裕ないんだけど</a></h2>
<p>あなたはすでにニッチな話をしています――ほとんどの人は償却の余裕があります．
しかも配列が償却されるのは最悪の場合で，あなたが配列を使うからと言って
必ず償却が行われるとは限りません．配列の要素数を予め知ることができるなら
（そうでなくても要素の上限を知ることができるなら）必要なメモリ空間を
とっておくことができます．経験上，要素数を予め知ることは<em>たいてい</em>できます．
特にRustではすべてのイテレータがこのためのメソッド<code>size_hint</code>を持っています．</p>
<p>この前提に立てば，<code>push</code>と<code>pop</code>は例外なくO(1)の操作で，連結リストの<code>push</code>と<code>pop</code>
より<em>かなり</em>速い操作になります．ただポインタを動かして，バイトデータを書き込んで，
Integerをインクリメントすればいいだけです．データを割り当てる必要なんかありません．</p>
<p>で，連結リストが低遅延だから使うんでしたっけ？</p>
<p><em>でももしデータ長が予測できないなら，連結リストで償却を回避できます！</em></p>
<h2><a class="header" href="#連結リストは消費メモリが少ない" id="連結リストは消費メモリが少ない">連結リストは消費メモリが少ない</a></h2>
<p>うーん，これはちょっと込み入った話ですね．「標準的な」配列のリサイズ戦略は
配列の半分が空になるように伸縮することです．たしかにこれは相当なメモリ空間を
無駄にしています．特にRustでは，collectionの要素を削除しても自動的に
縮めたりしません（なのでもう一度詰め込まない限り無駄になります）．したがって
無駄にしてるメモリ空間と時間の積は無限に膨れていきます！</p>
<p>しかしこれは最悪の場合です．最良の場合では，配列スタックはたった3つの
ポインタぶんのオーバーヘッドしかありません．基本的にはないと言っていいでしょう．</p>
<p>一方で連結リストは，無条件に要素一個ごとにオーバーヘッドがあります．
片方向リストではポインタ1つ，双方向リストではポインタ2つ分です．
この場合配列と違い，オーバーヘッドの割合は要素のデータサイズと関係してきます．
もしリストの要素が<em>どデカい</em>場合，オーバーヘッドはほぼ無視できるでしょう．
一方要素が小さい場合（1バイトとか），ポインタのオーバヘッドは要素自体の
16倍です！（要素が32bitのときは8倍です）</p>
<p>実際は要素全体の長さを揃えるためパディングが付加されるので23倍
（32bitのとき11倍）のことが多いでしょう．</p>
<p>ところでこれはアロケータの動きが最良の場合です．つまり，メモリの割当と解放が
密に行われ，断片化によってメモリが無駄にならない場合です．</p>
<p><em>でも，そうです．もしバカでかい要素を扱っていて，操作の頻度が予測できて，
賢いアロケータを使っているなら，メモリを節約できるでしょう！</em></p>
<h2><a class="header" href="#いつも関数型言語で連結リスト使ってたんだよね" id="いつも関数型言語で連結リスト使ってたんだよね">いつも&lt;関数型言語&gt;で連結リスト使ってたんだよね</a></h2>
<p>いいですね！連結リストは関数型言語では超いいですよね．ミューテーションなしで
操作できて，再帰的に表現できて，遅延評価の魔法のおかでげで無限長のリストを
扱えます．</p>
<p>特に優れている点は状態を持たずにイテレーションができる点です．イテレーションの
次のステップに行くためにはただ次のノードに行けばよいのです．</p>
<p>しかし，Rustでは配列のパターンマッチができて，<a href="https://doc.rust-lang.org/edition-guide/rust-2018/slice-patterns.html">スライスを使って</a>配列のサブセット
を扱うことができることは言っておくべきでしょう．これらの機能は実際関数型
言語のリストより表現の幅が大きいです．なぜなら配列の最後の要素や，
「ある配列の最初と最後と最後から二番目の要素を除いた配列」などの狂った
表現をを何でも扱えるからです．</p>
<p>でもスライスでリストを<em>作る</em>ことができないのは確かです．分割することしか
できません．</p>
<p>遅延評価については<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">イテレータ</a>があります．イテレータは無限の要素を持てて，
<code>map</code>，<code>filter</code>，<code>reverse</code>，結合などの操作を関数型のリストのように行なえますし，
これらの操作全てに遅延評価が適用されています．驚かないでいただきたいのですが
スライスはすべてイテレータとして扱うことができます．</p>
<p><em>でもそうです．もし不変のセマンティクスしか使えなければ，連結リストはとてもよい
選択でしょう．</em></p>
<p>誤解しないでいただきたいのですが，関数型言語が必ずしも雑魚いとか悪いとか
言っているわけではありません．しかし基本的にセマンティクスが制限されているのは
事実です．関数型言語においては，あるものが<em>どのようであるか</em>について記述できますが
<em>どのように行われるか</em>について記述することができません．これは<em>機能</em>であり，
それによっていろいろな<a href="https://wiki.haskell.org/GHC_optimisations#Fusion">変テコな操作</a>ができるようになったり，あなたを
煩わせることなく物事を成し遂げる<em>最良の</em>手段を取ることができるようになったり
します．しかし，それはあなたの手を煩わせる<em>ことができる</em>という選択肢と引き換え
に，です．たいてい緊急回避手段がありますが，そうでなければ手続き型コードを書く
ことになるでしょう．</p>
<p>関数型言語といえども，目的にあったデータ構造を選択する努力は行われるべきです．
確かに片方向連結リストは制御フローの記述には適していますが，データを保存して
検索するという目的には本当に向いていません．</p>
<h2><a class="header" href="#連結リストは並列データ構造を作るのに適している" id="連結リストは並列データ構造を作るのに適している">連結リストは並列データ構造を作るのに適している！</a></h2>
<p>そうですね！並列データ構造を書くということはまた別の問題であり，軽い問題でも
ありませんが，明らかに多くの人にとっては取り組もうとは<em>思いもしない</em>ことでしょう．
そして一度実装してしまったら，あなたは連結リストではなくMPSCキュー<sup class="footnote-reference"><a href="#3">3</a></sup>なり
なんなりを使うことになります．この場合連結リストはどっか遠くに行ってしまっています！</p>
<p><em>でもそうですね，並列処理の暗黒の世界において，連結リストは実績あるヒーローです．</em></p>
<h2><a class="header" href="#侵入型うんたらかんたらカーネルや組み込みどうのこうの" id="侵入型うんたらかんたらカーネルや組み込みどうのこうの">侵入型うんたらかんたらカーネルや組み込みどうのこうの</a></h2>
<p>はいニッチ．あなたは使ってる言語の<em>ランタイム</em>すら使わない場合の話をしてます．
それはあなたが変わったことをしてることを意味していますよね？</p>
<p>そのうえ激しくメモリ不安全です．</p>
<p><em>でももちろん，サイコーのメモリ節約リストをシステムに組み込んでください．</em></p>
<h2><a class="header" href="#連結リストのイテレータは関係ない挿入削除の影響を受けない" id="連結リストのイテレータは関係ない挿入削除の影響を受けない">連結リストのイテレータは関係ない挿入/削除の影響を受けない</a></h2>
<p>その話はかなりデリケートです．特にガベージコレクターがない場合には．
多分ですがあなたの制御フローと所有権の設計はすこしごちゃごちゃしている
かもしれません．詳しい状況によりますが．</p>
<p><em>でもそうですね，カーソルを使えば，本当にクールでクレイジーなことができます．</em></p>
<h2><a class="header" href="#連結リストはシンプルだし教えるのに適してる" id="連結リストはシンプルだし教えるのに適してる">連結リストはシンプルだし教えるのに適してる！</a></h2>
<p>うん，まあそうですね．あなたが読んでる本はそういう発想に基づいてます．
まあ片方向リストはとてもシンプルなんですけど，双方向リストはちょっと
ひどいです．</p>
<h1><a class="header" href="#閑話休題" id="閑話休題">閑話休題</a></h1>
<p>はい，こんなものでしょう．では大量の連結リストを書いていきましょう．</p>
<p><a href="first.html">第一章に行く！</a></p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>訳注：intrusive．ポインタではなく値を直接保持するデータ構造</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>訳注：amortization．ここでは配列の要素数を上回る数の要素を加えようとした際配列のサイズを大きくする，実行時に行われる操作</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>訳注：Multi-Producer-Single-Consumer Queue．複数の入力と単一の出力を持つ並列処理向きのキュー  </p>
</div>
<h1><a class="header" href="#クソ片方向スタック" id="クソ片方向スタック">クソ片方向スタック</a></h1>
<p>この章は<em>異常に</em>長い章になります．というのも，基本的にRustの全てをこの章で学ぶから
というのと，より良い理解のために茨の道を通って実装するからです．</p>
<p>最初のリストを<code>src/first.rs</code>に作りましょう．そしたらRustに<code>first.rs</code>が私達の
ライブラリが使うファイルであることを教えなければなりません．必要なことは<code>src/lib.rs</code>
（このファイルはCargoが自動的に作っておいてくれたはずです）にこのように書くことだけです：</p>
<pre><code class="language-rust ignore">// in lib.rs
pub mod first;
</code></pre>
<h1><a class="header" href="#基本データ設計" id="基本データ設計">基本データ設計</a></h1>
<p>よし，で，連結リストってなんでしょう？えー，基本的にはヒープに割り当てられたデータの山で
（カーネル勢はちょっと黙っててください），それぞれが順番に互いのポインタを持っています．
連結リストは，手続き型言語のプログラマが10m以内に近づかないものであり，関数型言語の
プログラマがあらゆる用途に使うものです．それなら，関数型言語のプログラマにどんなものか
説明してもらうのがよさそうですね．彼らはこんな感じの定義をよこすでしょう：</p>
<pre><code class="language-haskell">List a = Empty | Elem a (List a)
</code></pre>
<p>これはだいたい「リストは空か，リストが後ろにつながった要素である」みたいな感じに読めます．
<em>直和型</em>を用いた再起的な定義ですね．直和型というのは「異なる型の値を持つことができる型」
のことです．Rustでは直和型は<code>enum</code>に相当します！もしCライクな言語に慣れているなら，
Rustのenumはあなたが大好きなあのenumそのものです．じゃあ上の関数型の定義をRustっぽく
書き換えてみましょう！</p>
<p>とりあえず話を簡単にするためにジェネリクスは使わず，32bit intだけを要素として
持つことにします：</p>
<pre><code class="language-rust ignore">// in first.rs

// pubはListが外部から使えることを意味します
pub enum List {
    Empty,
    Elem(i32, List),
}
</code></pre>
<p>ぬわ疲．それじゃコンパイルしましょう：</p>
<pre><code class="language-text">&gt; cargo build

error[E0072]: recursive type `first::List` has infinite size
 --&gt; src/first.rs:4:1
  |
4 | pub enum List {
  | ^^^^^^^^^^^^^ recursive type has infinite size
5 |     Empty,
6 |     Elem(i32, List),
  |               ---- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `first::List` representable
</code></pre>
<p>えっと，あなたはどうか分かりませんが私は関数型界隈に裏切られた気分です．</p>
<p>エラーメッセージを見てみると（裏切られた絶望を乗り越えたあとで），rustcはまさに
エラーを解決する方法を示しています：</p>
<blockquote>
<p>insert indirection (e.g., a <code>Box</code>, <code>Rc</code>, or <code>&amp;</code>) at some point to make <code>first::List</code> representable</p>
</blockquote>
<p>おっけー，<code>box</code>ね．何それ？ググってみましょう．<code>rust box</code>...</p>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">std::boxed::Box - Rust</a></p>
</blockquote>
<p>これかな...</p>
<blockquote>
<p><code>pub struct Box&lt;T&gt;(_);</code></p>
<p>A pointer type for heap allocation.<br />
See the <a href="https://doc.rust-lang.org/std/boxed/">module-level documentation</a> for more.</p>
</blockquote>
<p><em>リンクをクリックする</em></p>
<blockquote>
<p><code>Box&lt;T&gt;</code>, casually referred to as a 'box', provides the simplest form of heap allocation in Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of scope.</p>
<p>Examples</p>
<p>Creating a box:</p>
<p><code>let x = Box::new(5);</code></p>
<p>Creating a recursive data structure:</p>
<p>（訳）
<code>Box&lt;T&gt;</code>，通称BoxはRustにおける最も単純なヒープ割当を行います．Boxは割り当てられたメモリの所有権を持ち，内容物はBoxがスコープから外れたときにdropされます．</p>
<p>使用例</p>
<p>Boxを作る：</p>
<p><code>let x = Box::new(5);</code></p>
<p>再帰的なデータ構造を作る：</p>
<pre><code>#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, Box&lt;List&lt;T&gt;&gt;),
    Nil,
}

let list: List&lt;i32&gt; = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
println!(&quot;{:?}&quot;, list);
</code></pre>
<p>This will print <code>Cons(1, Box(Cons(2, Box(Nil))))</code>.</p>
<p>Recursive structures must be boxed, because if the definition of Cons looked like this:</p>
<p><code>Cons(T, List&lt;T&gt;),</code></p>
<p>It wouldn't work. This is because the size of a List depends on how many elements are in the list, and so we don't know how much memory to allocate for a Cons. By introducing a Box, which has a defined size, we know how big Cons needs to be.</p>
<p>（訳）
これは<code>Cons(1, Box(Cons(2, Box(Nil))))</code>をprintします．</p>
<p>再帰的なデータ構造はBoxを持たなくてはいけません．もしConsの定義がこのようであった場合：</p>
<p><code>Cons(T, List&lt;T&gt;),</code></p>
<p>これは動きません．なぜならListの大きさはその要素数によるため，Consのためにどのくらいメモリを割り当てればよいか分からないからです．定義された大きさを持つBoxを使うことで，どのくらいConsが大きければよいかあらかじめ知ることができます．</p>
</blockquote>
<p>わお，うん．多分今まで見た中で一番知りたいことが書いてあるドキュメントですね．
ドキュメントのまさに最初に書いてあるのは<em>私達がやろうとしていたことそのものと，
なぜそれが動かないのかと，どうやって直すか</em>です．</p>
<p>ドキュメントが強すぎる．</p>
<p>よし，じゃあやってみましょう：</p>
<pre><code class="language-rust ignore">pub enum List {
    Empty,
    Elem(i32, Box&lt;List&gt;),
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

   Finished dev [unoptimized + debuginfo] target(s) in 0.22s
</code></pre>
<p>やった，ビルドが通りました！</p>
<p>...でもちょっと考えてみるとこれはかなりバカっぽいリストです．</p>
<p>要素が2つあるリストを考えてみましょう．</p>
<pre><code class="language-text">[] = スタック
() = ヒープ

[要素A, ポインタ] -&gt; (要素B, ポインタ) -&gt; (Empty *ゴミ*)
</code></pre>
<p>問題は2つあります：</p>
<ul>
<li>最後のノードは「僕は実はノードじゃないヨ」を意味するデータを割り当てられている．</li>
<li>最初のノードは全くヒープのメモリ空間を割り当てられていない．</li>
</ul>
<p>表面的には，これらは互いに打ち消し合っているように見えます．一方で追加のノードを
割当て，もう一方では割り当てていない...でも次のようなデータ構造を見てみましょう：</p>
<pre><code class="language-text">[ポインタ] -&gt; (要素A, ポインタ) -&gt; (要素B, *null*)
</code></pre>
<p>この構成では要素数に関わらず各要素のためにヒープのメモリ空間を割り当てます．
重要な違いは一つ目の設計にあった<em>ゴミ</em>がないことです．このゴミはなんなのでしょうか？
それを知るために，enumがどのようにメモリに割り当てられるか見てみましょう．</p>
<p>一般にenumはこんな感じです：</p>
<pre><code class="language-rust ignore">enum Foo {
    D1(T1),
    D2(T2),
    ...
    Dn(Tn),
}
</code></pre>
<p>Fooはどの<em>列挙子</em>（<code>D1</code>, <code>D2</code>, .. <code>Dn</code>）であるかを表す整数をもつ必要があります．これが
enumの<em>タグ</em>です．それに加え，<code>T1</code>, <code>T2</code>, .. <code>Tn</code>のうち<em>最大の</em>ものが入るメモリ空間が
必要になります（あとメモリの整列のためのパディング）．</p>
<p>ここで発生している大いなるムダは，<code>Empty</code>がたった1bitの情報であるにもかかわらずポインタ1個と
要素1個分のメモリが必要であることです．<code>Elem</code>にいつ変換されてもいいようにしなくてはならないのです．
そんなわけで1つ目の設計ではゴミデータを割り当てざるを得ず，2つ目の構成より若干大きい
スペースが必要になります．</p>
<p>ノードの一つがヒープにないのも，常に全ノードがヒープに割り当てられるより，多分ビビるほど
<em>悪い</em>です．ノードの扱いが統一的でないと，pushやpopではそれほど困らないかもしれませんが
分割や結合の際に厄介なことになります．</p>
<p>それぞれの設計でリストを分割することを考えてみましょう：</p>
<pre><code class="language-text">設計1:

[要素A, ポインタ] -&gt; (要素B, ポインタ) -&gt; (要素C, ポインタ) -&gt; (Empty *ゴミ*)

Cを分割:

[要素A, ポインタ] -&gt; (要素B, ポインタ) -&gt; (Empty *ゴミ*)
[要素C, ポインタ] -&gt; (Empty *ゴミ*)
</code></pre>
<pre><code class="language-text">設計2:

[ポインタ] -&gt; (要素A, ポインタ) -&gt; (要素B, ポインタ) -&gt; (要素C, *null*)

Cを分割:

[ポインタ] -&gt; (要素A, ポインタ) -&gt; (要素B, *null*)
[ポインタ] -&gt; (要素C, *null*)
</code></pre>
<p>設計2では要素Bのポインタをスタックにコピーして，元あった場所をnullにするだけです．
設計1でも同じことをしていますが，要素Cをヒープからスタックにコピーする必要があります．
結合は同じことを逆にやるだけです．</p>
<p>連結リストの数少ない良いところのひとつに要素をノード自体の中で組み立て，メモリ空間を
移動させずに順番を入れ替える事ができる点があります．ポインタをいじるだけでリスト内の
順番が動くのです．設計1はこの特長を持ちません．</p>
<p>はい，設計1がクソなことが証明されました．ではどう書き直せばいいでしょうか？じゃあこんな
感じで：</p>
<pre><code class="language-rust ignore">pub enum List {
    Empty,
    ElemThenEmpty(i32),
    ElemThenNotEmpty(i32, Box&lt;List&gt;),
}
</code></pre>
<p>悪化してるように見えたなら良かったです．特筆すべき点は，この設計は<code>ElemThenNotEmpty(0, Box(Empty))</code>
というまったく無意味な状態を持てるようになっており，ロジックを複雑にしていることです．
しかも相変わらずノードがスタックにあったりヒープにあったりします．</p>
<p>とはいえ，この設計は<em>ひとつ</em>興味深い特徴を持っています：Emptyの状態がなく，ヒープの
割当が1要素分小さいことです．不幸にもそれによって<em>更に大きい</em>メモリ空間を無駄にしている
んですけどね！なぜかというと，先程の設計が<em>ヌルポインタ最適化</em>を行っているからです．</p>
<p>さっきenumはどの列挙子を持つかを管理するタグを持っていると言いました．しかし，このような
特別な形のenumについては：</p>
<pre><code class="language-rust ignore">enum Foo {
    A,
    B(ContainsANonNullPtr),
}
</code></pre>
<p>ヌルポインタ最適化が行われ，<em>タグのためにはメモリ空間が使われなくなります</em>．列挙子Aのとき
enumはすべて<code>0</code>が割り当てられ，そうでないとき列挙子Bが割り当てられます．列挙子Bはnullでない
ポインタを含むため，中身が全て<code>0</code>ということはあり得ないのでこういう事ができるのです．
かっこいい！</p>
<p>他にこういう最適化ができるenumの形はどんなのがあるか思いつきますか？実はいっぱいあります！
これがRustがenumのメモリレイアウトを定義しない理由です．他にもいくつか複雑なRustの
enumメモリレイアウト最適化戦略がありますが，ヌルポインタ最適化が明らかに一番重要です！
ヌルポインタ最適化によって<code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, <code>Rc</code>, <code>Arc</code>, <code>Vec</code>などを<code>Option</code>
に入れてもオーバーヘッドが発生しません（これらの型についてはおいおい触れます）．</p>
<p>で，どうすればゴミデータの割当を防ぎ，統一的にメモリを割り当たうえでヌルポインタ最適化
の恩恵を得ることができるでしょうか？要素を持つということとリストを新しく割り当てるという
ことを切り離して考えるほうがよさそうです．そのためにはCライクな構造体についてもう少し
考えなくてはいけません！</p>
<p>enumがいくつかある値の<em>ひとつ</em>を保持する型なら，構造体は<em>複数</em>を一度に保持する型です．
リストを2つの型に分割しましょう．ListとNodeです．</p>
<p>さっきと同様Listは空（Empty）かリストが後ろにくっついた要素です．「リストが後ろに
くっついた要素」を別の型で表現することでBoxをさらに最適化された状態にもっていく
ことができます：</p>
<pre><code class="language-rust ignore">struct Node {
    elem: i32,
    next: List,
}

pub enum List {
    Empty,
    More(Box&lt;Node&gt;),
}
</code></pre>
<p>ちゃんとできてるか確認してみましょう：</p>
<ul>
<li>リストの末尾にゴミがない：OK!</li>
<li><code>enum</code>がヌルポインタ最適化されている：OK!</li>
<li>ノードが統一的に割り当てられる：OK!</li>
</ul>
<p>よし！これで問題があった（ことがRustの公式ドキュメントに指摘された）はじめの設計
の問題点を克服しました．</p>
<pre><code class="language-text">&gt; cargo build

warning: private type `first::Node` in public interface (error E0446)
 --&gt; src/first.rs:8:10
  |
8 |     More(Box&lt;Node&gt;),
  |          ^^^^^^^^^
  |
  = note: #[warn(private_in_public)] on by default
  = warning: this was previously accepted by the compiler but
    is being phased out; it will become a hard error in a future release!
</code></pre>
<p>:(</p>
<p>またRustに怒られました．<code>List</code>を（外部から使ってほしいので）publicにしましたが<code>Node</code>
をpublicにはしていませんでした．問題は，publicな<code>enum</code>の中は全てpublicでなくてはならないことです．
<code>Node</code>をpublicにすることもできますが，一般にRustでは実装の詳細を隠蔽することが好まれます．
<code>List</code>を構造体にすることで実装の詳細を隠すことにしましょう：</p>
<pre><code class="language-rust ignore">pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}

struct Node {
    elem: i32,
    next: Link,
}
</code></pre>
<p><code>List</code>はフィールドがひとつしかない構造体なので，サイズはフィールドと同じになります．
ゼロコスト抽象化です．イエーイ！</p>
<pre><code class="language-text">&gt; cargo build

warning: field is never used: `head`
 --&gt; src/first.rs:2:5
  |
2 |     head: Link,
  |     ^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: variant is never constructed: `Empty`
 --&gt; src/first.rs:6:5
  |
6 |     Empty,
  |     ^^^^^

warning: variant is never constructed: `More`
 --&gt; src/first.rs:7:5
  |
7 |     More(Box&lt;Node&gt;),
  |     ^^^^^^^^^^^^^^^

warning: field is never used: `elem`
  --&gt; src/first.rs:11:5
   |
11 |     elem: i32,
   |     ^^^^^^^^^

warning: field is never used: `next`
  --&gt; src/first.rs:12:5
   |
12 |     next: Link,
   |     ^^^^^^^^^^

</code></pre>
<p>よっしゃ，コンパイルが通りました！Rustは私達が作ったものが完全に無駄だといって
めちゃくちゃ怒ってます．<code>head</code>をどこでも使ってないし，プライベートフィールドなので
外部からも参照できないからです．したがって<code>Link</code>と<code>Node</code>も同様に無意味というわけです．
というわけで次はこれを解決しましょう．このリストを使うコードを実装していきましょう！</p>
<h1><a class="header" href="#new" id="new">New</a></h1>
<p>型に対して実装を行うためには<code>impl</code>を使います：</p>
<pre><code class="language-rust ignore">impl List {
    // TODO: コードを書く
}
</code></pre>
<p>あとはコードの書き方がわかればいいだけです．Rustではこんな感じに関数を宣言します：</p>
<pre><code class="language-rust ignore">fn foo(arg1: Type1, arg2: Type2) -&gt; ReturnType {
    // body
}
</code></pre>
<p>はじめに必要なのはリストを<em>作る</em>手段です．実装を隠蔽するので関数化する必要が
あります．Rustでの一般的なやりかたはスタティックメソッドを作るというもので，
<code>impl</code>のなかに普通に関数を書きます：</p>
<pre><code class="language-rust ignore">impl List {
    pub fn new() -&gt; Self {
        List { head: Link::Empty }
    }
}
</code></pre>
<p>いくつか注意事項があります：</p>
<ul>
<li>Selfというのは「上にある<code>impl</code>のすぐ右に書いた型」のことです．繰り返しが少ないのはよいことですね！</li>
<li>構造体のインスタンスの生成は宣言とほぼ同じですが，フィールドの型を指定する代わりに値を与えます．</li>
<li>enumの列挙子の指定に<code>::</code>を使いました．これは名前空間を区切る識別子です．</li>
<li>関数の最後に書かれたものが返り値になります．これによって簡単な関数を若干きれいに書けます．
もちろん他のCライク言語のように<code>return</code>文を使って早期リターンすることもできます．</li>
</ul>
<h1><a class="header" href="#所有権" id="所有権">所有権</a></h1>
<p>リストを作ることができるようになったので，次はリストで何か<em>できる</em>ようになると
いいですね．それを実現するために普通の（スタティックでない）メソッドを使います．
メソッドは<code>self</code>という型のない引数を持つ，関数の特別な形です：</p>
<pre><code class="language-rust ignore">fn foo(self, arg2: Type2) -&gt; ReturnType {
    // body
}
</code></pre>
<p>selfは主に3つの形をとります：<code>self</code>，<code>&amp;mut self</code>，そして <code>&amp;self</code>です．
これらはRustにおける所有権の3つの形に対応しています：</p>
<ul>
<li><code>self</code> - 値</li>
<li><code>&amp;mut self</code> - 可変参照</li>
<li><code>&amp;self</code> - 共有参照</li>
</ul>
<p>値は<em>本物の</em>所有権を表します．この値を煮るなり焼くなり動かすなり破壊するなり変更するなり
参照を貸し出すなり自由です．何かの値を渡したとき，それは渡されたところに<em>ムーブされます</em>．
そして渡されたほうがその値の所有権を持つようになり，渡したほうからはアクセスできなく
なります．なので，たいていのメソッドでは<code>self</code>を使いません．pushやpopするたびに
アクセスできなくなるリストを使うのはそうとうアホですしね！</p>
<p>可変参照は，所有権を持たない値の一時的かつ<em>排他的</em>なアクセスを表します．
可変参照を持つ値に対して何をしても大丈夫ですが，所有権を返すときに有効な状態に
しておく必要があります（でないと借りた人に失礼ですからね！）．値を完全に書き換えて
しまうこともできるので，別の値と<em>すり替える</em>ようなこともできます．値のすり替えは
このあと沢山やることになります．<code>&amp;mut</code>に対して唯一できないことは代わりの値を
用意せずにムーブしてしまうことです．<code>&amp;mut self</code>をもつメソッドは<code>self</code>に対して
変更を加えたいときにとても有用なメソッドです．</p>
<p>共有参照は，所有権を持たない値の一時的で，<em>共有された</em>アクセスを表します．
共有されているので，値に対して変更を加えることはできません．<code>&amp;</code>は値を
博物館のガラスケースに入れてるようなものだと考えてください．<code>self</code>の状態を
取得したいだけのときは<code>&amp;</code>が特に有用です．</p>
<p>あとでこのルールは回避可能であることを見ていきます．共有参照が<em>不変</em>参照と
呼ばれていないのはそういう理由からです．可変参照は<em>唯一無二</em>参照とか
呼ばれるべきかもしれませんが，所有権と値の可変性は99%の場合直感に即している
ことがわかりました．</p>
<h1><a class="header" href="#push" id="push">Push</a></h1>
<p>ではリストに値を追加（push）する操作を書いていきましょう．<code>push</code>は
リストの変更を伴うので<code>&amp;mut self</code>を引数に取ります．pushするi32の値も
引数に取る必要があります：</p>
<pre><code class="language-rust ignore">impl List {
    pub fn push(&amp;mut self, elem: i32) {
        // TODO
    }
}
</code></pre>
<p>まずは要素をいれるNodeを作りましょう．</p>
<pre><code class="language-rust ignore">    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Node {
            elem: elem,
            next: ?????
        };
    }
</code></pre>
<p><code>next</code>には何が入るでしょうか？えーっと，リスト全部です！たぶん...こう？</p>
<pre><code class="language-rust ignore">impl List {
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Node {
            elem: elem,
            next: self.head,
        };
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
error[E0507]: cannot move out of borrowed content
  --&gt; src/first.rs:19:19
   |
19 |             next: self.head,
   |                   ^^^^^^^^^ cannot move out of borrowed content
</code></pre>
<p>うえええええん．Rustは私達に正論を突きつけています．でもこれが具体的に何を
意味するのか，あるいはどうすればいいかは判然としません：</p>
<blockquote>
<p>cannot move out of borrowed content</p>
</blockquote>
<p>私達は<code>self.head</code>を<code>next</code>にムーブしようとしましたが，Rustはそういうことを
やってほしくないようです．これをすると<code>self</code>は一部が欠けた状態でこのメソッド
から返されることになります．すでに見たとおり，これは<code>&amp;mut</code>で唯一許されていない
ことです．借りたものをちゃんと返さないのは超失礼なことで，Rustはとても真面目なのです
（超危険なことでもあるのですが，今回はそういう問題ではありません）．</p>
<p>では何かを戻したらどうでしょう？つまり，今作ったノードとか：</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: i32) {
    let new_node = Box::new(Node {
        elem: elem,
        next: self.head,
    });

    self.head = Link::More(new_node);
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
error[E0507]: cannot move out of borrowed content
  --&gt; src/first.rs:19:19
   |
19 |             next: self.head,
   |                   ^^^^^^^^^ cannot move out of borrowed content
</code></pre>
<p>だめかー．原則的にはこれはRust的にはOKなのですが，実際にはだめです（理由はいくつか
ありますが，<a href="https://doc.rust-lang.org/nightly/nomicon/exception-safety.html">例外に対する安全性</a>が一番深刻な問題です）．Rustに値を取ったと
気づかれないように取る方法が必要です．ここは悪名高いRustのハッカー，
インディ・ジョーンズに教えを請うことにしましょう：</p>
<p><img src="img/indy.gif" alt="mem::replaceの構えを取るインディ" /></p>
<p>ああ！インディは<code>mem::replace</code>を使うことを提案しています．この超有能な関数を使うと，
借りた値を代わりのものと入れ替えることで盗んでしまうことができます．まずは
<code>std::mem</code>をファイルの先頭に持ってきて<code>mem</code>をローカルスコープで使えるようにしましょう：</p>
<pre><code class="language-rust ignore">use std::mem;
</code></pre>
<p>そしていい感じに使います：</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: i32) {
    let new_node = Box::new(Node {
        elem: elem,
        next: mem::replace(&amp;mut self.head, Link::Empty),
    });

    self.head = Link::More(new_node);
}
</code></pre>
<p>ここで，新しいノードをいれる前，一時的にself.headをLink::Emptyにしています．
今から嘘をつきます．こういうことをしなきゃいけないのは不幸なことです．こうする
他に方法はないのです（いまのところは）．</p>
<p>でもこれで<code>push</code>は完成です！多分．多分テストしたほうが良さそうですね，正直．
とりあえず一番簡単なやり方は<code>pop</code>を書いて，予期したとおりに動くことを確認する
ことでしょう．</p>
<h1><a class="header" href="#pop" id="pop">Pop</a></h1>
<p><code>push</code>同様，<code>pop</code>もリストに変更を加えますが，<code>push</code>と違い返り値があります．
そしてリストが空の場合という厄介な状態を考えなくてはいけません．この
ケースに対処するために，信頼できる<code>Option</code>型を使います：</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    // TODO
}
</code></pre>
<p><code>Option&lt;T&gt;</code>は値が存在するかもしれないことを表すのに使われ，<code>Some(T)</code>か<code>None</code>
の状態を取ることができます．Linkのときやったように似たような型を自作することも
できますが，このリストを使う人が戻り値の型が一体全体何なのか考えなくていいように，
Optionという知らない人がいないほどありふれてる型を使います．実際あまりにも
基礎的なので何も書かなくても<code>Some</code>と<code>None</code>と一緒にすべての.rsファイルに
インポートされています（なので<code>Option::None</code>とか書かなくてもいいのです）．</p>
<p><code>Option&lt;T&gt;</code>のとげとげはOptionがTの<em>ジェネリック型</em>であることを表しています．
どんな型のOptionも作ることができるのです！</p>
<p>はい，で，この<code>Link</code>とかいうのがあるわけですが，どうやってこれがEmptyかMoreか
判断するのでしょうか？<code>match</code>を使ったパターンマッチングです！</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match self.head {
        Link::Empty =&gt; {
            // TODO
        }
        Link::More(node) =&gt; {
            // TODO
        }
    };
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0308]: mismatched types
  --&gt; src/first.rs:27:30
   |
27 |     pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
   |            ---               ^^^^^^^^^^^ expected enum `std::option::Option`, found ()
   |            |
   |            this function's body doesn't return
   |
   = note: expected type `std::option::Option&lt;i32&gt;`
              found type `()`
</code></pre>
<p>おおおっと．<code>pop</code>は値を返さなくてはいけませんが，まだ実装してませんでした．
<code>None</code>を返すこともできますが，このような場合は関数がまだ未実装であることを
表す<code>unimplemented!()</code>を返すのがよさそうです．<code>unimplemented!()</code>はマクロで
（<code>!</code>がマクロであることを表しています），実行するとプログラムがパニックします
（制御下でクラッシュさせます）．</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match self.head {
        Link::Empty =&gt; {
            // TODO
        }
        Link::More(node) =&gt; {
            // TODO
        }
    };
    unimplemented!()
}
</code></pre>
<p>無条件でパニックするような関数は<a href="https://doc.rust-jp.rs/book/second-edition/ch19-04-advanced-types.html#never%E5%9E%8B%E3%81%AF%E7%B5%B6%E5%AF%BE%E3%81%AB%E8%BF%94%E3%82%89%E3%81%AA%E3%81%84">発散する関数</a>と呼ばれます．
発散する関数は値を返さず，したがってどんな型の値としても使うことが
できます．ここでは<code>unimplemented!()</code>の返り値を<code>Option&lt;T&gt;</code>として使っています．</p>
<p><code>return</code>を書かなくていいことにも注目してください．最後の表現（基本的には行）
が暗黙的に関数の返り値になります．これでシンプルな関数をより簡潔に書くことが
できるのです．ほかのCライクな言語のように，明示的に<code>return</code>を使って
早期リターンすることもできます．</p>
<pre><code class="language-text">&gt; cargo build

error[E0507]: cannot move out of borrowed content
  --&gt; src/first.rs:28:15
   |
28 |         match self.head {
   |               ^^^^^^^^^
   |               |
   |               cannot move out of borrowed content
   |               help: consider borrowing here: `&amp;self.head`
...
32 |             Link::More(node) =&gt; {
   |                        ---- data moved here
   |
note: move occurs because `node` has type `std::boxed::Box&lt;first::Node&gt;`, which does not implement the `Copy` trait
  --&gt; src/first.rs:32:24
   |
32 |             Link::More(node) =&gt; {
   |                        ^^^^
</code></pre>
<p>頼むぞRust，邪魔しないでくれ！いつもどおりRustは激おこです．ありがたいことに
今回は何がいけないのか全部言ってくれています！デフォルトでは，パターンマッチを
するときmatch節への値のムーブが発生します．しかし今回はself.headの所有権を
持っていないためそれはできません．</p>
<pre><code class="language-text">help: consider borrowing here: `&amp;self.head`
</code></pre>
<p>Rustは<code>match</code>節で参照を使えと言ってます．🤷‍♀️まあ試してみましょう：</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match &amp;self.head {
        Link::Empty =&gt; {
            // TODO
        }
        Link::More(ref node) =&gt; {
            // TODO
        }
    };
    unimplemented!()
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

warning: unused variable: `node`
  --&gt; src/first.rs:32:24
   |
32 |             Link::More(node) =&gt; {
   |                        ^^^^ help: consider prefixing with an underscore: `_node`
   |
   = note: #[warn(unused_variables)] on by default

warning: field is never used: `elem`
  --&gt; src/first.rs:13:5
   |
13 |     elem: i32,
   |     ^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

warning: field is never used: `next`
  --&gt; src/first.rs:14:5
   |
14 |     next: Link,
   |     ^^^^^^^^^^
</code></pre>
<p>イエーイ，コンパイルが通りました！ではTODOに入る処理を考えていきましょう．
Optionを返したいので，そのための変数を作りましょう．EmptyのときにはNoneを
返せばいいですね．Moreのときは<code>Some(i32)</code>を返し，Listのheadを更新します．
じゃあとりあえずはこんな感じでどうでしょうか？</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    let result;
    match &amp;self.head {
        Link::Empty =&gt; {
            result = None;
        }
        Link::More(ref node) =&gt; {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (/Users/ABeingessner/dev/temp/lists)
error[E0507]: cannot move out of borrowed content
  --&gt; src/first.rs:35:29
   |
35 |                 self.head = node.next;
   |                             ^^^^^^^^^ cannot move out of borrowed content

</code></pre>
<p><em>(頭を机に伏せる)</em></p>
<p>共有参照しか持ってない<code>node</code>から値を取ろうとしているのがよくないようです．</p>
<p>ここは一旦私達が何をしようとしているのか考え直すべきでしょう．私達がやりたいのは
こういうことです：</p>
<ul>
<li>リストが空か確認する</li>
<li>もし空ならNoneを返す</li>
<li>もし空<em>でない</em>なら...
<ul>
<li>リストのheadを消す</li>
<li>headの<code>elem</code>を消す</li>
<li>リストのheadを古いheadの<code>next</code>に更新する</li>
<li><code>Some(elem)</code>を返す</li>
</ul>
</li>
</ul>
<p>重要な点は私達がなにかを<em>消そう</em>としている点です．つまり，リストのheadの<em>値</em>を
持っている必要があります．これは明らかに<code>&amp;self.head</code>の共有参照を使っていては
達成できません．そもそもこの関数は<code>self</code>の可変参照<em>しか</em>持っておらず，
<em>入れ替える</em>ことでしか値を取ることができません．これはまたEmptyの出番のよう
ですね！</p>
<p>試してみましょう：</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    let result;
    match mem::replace(&amp;mut self.head, Link::Empty) {
        Link::Empty =&gt; {
            result = None;
        }
        Link::More(node) =&gt; {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
}
</code></pre>
<pre><code class="language-text">cargo build

   Finished dev [unoptimized + debuginfo] target(s) in 0.22s
</code></pre>
<p>や　っ　た　ぜ</p>
<p><em>一つの</em>警告もなくコンパイルしました！！！！！</p>
<p>ちょっとここで個人的なlintを行いたいと思います．私達は<code>result</code>を返り値に
していますが，実はそんなことをする必要はないのです！関数がその最後の行を
返すように，全ての節もその最後の行を返すのです．普通はセミコロンをつけることで
空タプル<code>()</code>を返すようにします．返り値を定義していない関数（<code>push</code>みたいな）も
空タプルを返します．</p>
<p>そんなわけで，<code>pop</code>はこんなふうに書けます：</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match mem::replace(&amp;mut self.head, Link::Empty) {
        Link::Empty =&gt; None,
        Link::More(node) =&gt; {
            self.head = node.next;
            Some(node.elem)
        }
    }
}
</code></pre>
<p>この方が簡潔で慣用的です．Link::Emptyのところにカッコがないことに注目してください．
一つしか表現がないシンプルな場合にはこのように書くことができます．</p>
<pre><code class="language-text">cargo build

   Finished dev [unoptimized + debuginfo] target(s) in 0.22s
</code></pre>
<p>よしよし，これでも動きますね！</p>
<h1><a class="header" href="#テスト" id="テスト">テスト</a></h1>
<p>さてさて，<code>push</code>と<code>pop</code>が書けたので実際にスタックをテストしてみましょう！
RustとCargoはテストを第一級の機能としてサポートしているので，テストを書くのは
超カンタンです．関数を書いて<code>#[test]</code>アノテーションをつければよいだけです．</p>
<p>一般にRust界隈ではテストコードをテストされるコードの横に書く慣習があります．
しかし，通常は名前の衝突を避けるためテストのための名前空間を用意します．<code>first.rs</code>
を<code>lib.rs</code>で使えるように<code>mod</code>を使ったのと同じように，<code>mod</code>キーワードを使えば
新しいファイルを作るのと同じようなことを<em>インラインで</em>することができます：</p>
<pre><code class="language-rust ignore">// in first.rs

mod test {
    #[test]
    fn basics() {
        // TODO
    }
}
</code></pre>
<p><code>cargo test</code>で実行します．</p>
<pre><code class="language-text">&gt; cargo test
   Compiling lists v0.1.0 (/Users/ABeingessner/dev/temp/lists)
    Finished dev [unoptimized + debuginfo] target(s) in 1.00s
     Running /Users/ABeingessner/dev/lists/target/debug/deps/lists-86544f1d97438f1f

running 1 test
test first::test::basics ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
; 0 filtered out
</code></pre>
<p>イエーイ　私達の何もしないテストは無事通りました！これを何もしなくないように
していきましょう．そのためには<code>assert_eq!</code>マクロを使います．これは不思議な
魔法のたぐいではなく，与えた2つの値を比較してそれらが違えばパニックするだけです．
キョドることでテストの失敗を知らせるのです！</p>
<pre><code class="language-rust ignore">mod test {
    #[test]
    fn basics() {
        let mut list = List::new();

        // 空のリストが動くことを確認
        assert_eq!(list.pop(), None);

        // リストの要素をつめる
        list.push(1);
        list.push(2);
        list.push(3);

        // 普通に要素を削除してみる
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // 何も壊れてないことを確認するためにもう一回push
        list.push(4);
        list.push(5);

        // 普通に要素を削除してみる
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // リストを出し切ったとき
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

error[E0433]: failed to resolve: use of undeclared type or module `List`
  --&gt; src/first.rs:43:24
   |
43 |         let mut list = List::new();
   |                        ^^^^ use of undeclared type or module `List`


</code></pre>
<p>おおっと！<code>mod</code>で新しいモジュールを切ったのでListを明示的に宣言しなくてはいけません．</p>
<pre><code class="language-rust ignore">mod test {
    use super::List;
    // 後は同じ
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

warning: unused import: `super::List`
  --&gt; src/first.rs:45:9
   |
45 |     use super::List;
   |         ^^^^^^^^^^^
   |
   = note: #[warn(unused_imports)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running /Users/ABeingessner/dev/lists/target/debug/deps/lists-86544f1d97438f1f

running 1 test
test first::test::basics ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
; 0 filtered out
</code></pre>
<p>やりい！</p>
<p>でもこの警告は何でしょう...？Listはどう見ても使ってるだろ！</p>
<p>...でもテストのためだけに，ですね！コンパイラを黙らせるために（そしてこの
パッケージを使う人にわかりやすいように）<code>test</code>モジュール全体をテストのとき
だけにコンパイルされるようにしましょう．</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;
    // 後は同じ
}
</code></pre>
<p>これでテストは完成です！</p>
<h1><a class="header" href="#drop" id="drop">Drop</a></h1>
<p>スタックを作りましたし，pushとpopもできるようになりましたし，テストまで実装して
ちゃんと動くこともわかりました！</p>
<p>リストの後片付けをするコードを書く必要があるでしょうか？技術的には
ノーです．全く必要ありません！C++のように，Rustはデストラクタを使って使い終わった
リソースを自動的に解放してくれます．Dropという名前の<em>トレイト</em>を実装することで
デストラクタを型に与えることができます．Rustではインターフェースをトレイト
と呼びます．Dropはこんな感じのインターフェースです：</p>
<pre><code class="language-rust ignore">pub trait Drop {
    fn drop(&amp;mut self);
}
</code></pre>
<p>基本的には，スコープの外に出たときに後片付けのためにdropが実行されます．</p>
<p>実はDropを実装してある型を含む型に対してはDropを実装しなくてもよく，その
Dropが実装してある型のデストラクタを呼べばいいだけです．私達が実装したListの場合
デストラクタではheadを消せばいいだけですから，何も実装しなくても<code>Box&lt;Node&gt;</code>を
消してくれる<em>はず</em>です．全ては自動的に処理されます...が，一つだけ問題があります．</p>
<p>その自動処理はクソです．</p>
<p>こんな感じの簡単なリストを考えてみましょう：</p>
<pre><code class="language-text">list -&gt; A -&gt; B -&gt; C
</code></pre>
<p><code>list</code>がdropされるとき，<code>list</code>はAをdropしようとし，AはBを，BはCをdropしようとします．
不安になってきた人もいますよね？これは再帰なので，スタックを消費し尽くしてしまう
可能性があります！</p>
<p>「これは末尾再帰だから，ちゃんとした言語ならスタックが尽きないようにしてくれるだろ」
と思った人もいるでしょう．それは，実は，間違いです！理由を知るために，コンパイラが
実際にするであろう処理をdropとして実装してみましょう：</p>
<pre><code class="language-rust ignore">impl Drop for List {
    fn drop(&amp;mut self) {
        // NOTE: 本当は`drop`を明示的に呼ぶことはできません
        // 今はコンパイラのふりをしています！
        self.head.drop(); // 末尾再帰 - good!
    }
}

impl Drop for Link {
    fn drop(&amp;mut self) {
        match *self {
            Link::Empty =&gt; {} // おわり！
            Link::More(ref mut boxed_node) =&gt; {
                boxed_node.drop(); // 末尾再帰 - good!
            }
        }
    }
}

impl Drop for Box&lt;Node&gt; {
    fn drop(&amp;mut self) {
        self.ptr.drop(); // あーっ，末尾再帰じゃない！
        deallocate(self.ptr);
    }
}

impl Drop for Node {
    fn drop(&amp;mut self) {
        self.next.drop();
    }
}
</code></pre>
<p>Boxを<code>deallocate</code>した<em>後に</em>中身をdropすることは<em>できません</em>．したがって末尾再帰で
このListをdropすることはできないのです！なのでBoxからNodeを取り出してdropする
反復処理を書かなくてはいけません．</p>
<pre><code class="language-rust ignore">impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = mem::replace(&amp;mut self.head, Link::Empty);
        // `while let` == 「パターンにマッチしなくなるまでループする」
        while let Link::More(mut boxed_node) = cur_link {
            cur_link = mem::replace(&amp;mut boxed_node.next, Link::Empty);
            // boxed_nodeはここでスコープから外れdropされます
            // しかしそのNodeの`next`はすでにLink::Emptyになっているので
            // dropは再帰しません
        }
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 1 test
test first::test::basics ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>いいですね！</p>
<hr />
<p><span style="float:left"><img src="img/profbee.gif" alt="Bonus" /></span></p>
<h2><a class="header" href="#おまけ早期最適化" id="おまけ早期最適化">おまけ：早期最適化</a></h2>
<p>私達が実装した<code>drop</code>は<code>while let Some(_) = self.pop() { }</code>に<em>とても</em>よく
似ていますし，そう書いたほうが簡潔です．これらの違いはなんでしょうか？
また，リストにint以外を入れた場合パフォーマンスにどのように影響する
でしょうか？</p>
<details>
  <summary>クリックして答えを見る</summary>
<p><code>pop</code>は<code>Option&lt;i32&gt;</code>を返しますが，私達の実装ではLink（<code>Box&lt;Node&gt;</code>）に対する操作を行います．つまり，私達の実装はNodeのポインタを
動かすだけであるのに対し，popはNodeの値をムーブするのです．もしListを一般化してDrop実装済みめちゃデカ型（VeryBigThingWithADropImpl
　略して　VBTWADI）も入れられるようにしたとき，これは超コストのかかる操作になるおそれがあります．しかし，Boxは内容物のDropをそのまま
呼べるのでこの問題を回避することができます．VBTWADIを入れることこそが<em>まさしく</em>配列ではなく連結リストを使うメリットなので，VBTWADIを
使うときパフォーマンスが良くなかったらちょっと残念ですよね．</p>
<p>両方の実装のいいとこ取りをしたいなら，新しく<code>fn pop_node(&amp;mut self) -&gt; Link</code>というメソッドを
作り，これを使って<code>pop</code>と<code>drop</code>を実装するのがいいでしょう．</p>
</details>
<h1><a class="header" href="#最終コード" id="最終コード">最終コード</a></h1>
<p>はい，このコードを書くまでに6000語（翻訳前）かかりました：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::mem;

pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -&gt; Self {
        List { head: Link::Empty }
    }

    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: mem::replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match mem::replace(&amp;mut self.head, Link::Empty) {
            Link::Empty =&gt; None,
            Link::More(node) =&gt; {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = mem::replace(&amp;mut self.head, Link::Empty);

        while let Link::More(mut boxed_node) = cur_link {
            cur_link = mem::replace(&amp;mut boxed_node.next, Link::Empty);
        }
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // 空のリストが動くことを確認
        assert_eq!(list.pop(), None);

        // リストの要素をつめる
        list.push(1);
        list.push(2);
        list.push(3);

        // 普通に要素を削除してみる
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // 何も壊れてないことを確認するためにもう一回push
        list.push(4);
        list.push(5);

        // 普通に要素を削除してみる
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // リストを出し切ったとき
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }
}
#}</code></pre></pre>
<p>マジかよ，80行しかないし半分はテストだぞ！最初に長い章になりますと言ったとおりに
なりましたね．</p>
<h1><a class="header" href="#まあまあな片方向連結スタック" id="まあまあな片方向連結スタック">まあまあな片方向連結スタック</a></h1>
<p>前章ではギリ実用に耐える片方向連結スタックを書きました．しかし，
前章のリストにはいくつか設計上の問題があり，ゆえにクソです．
これをクソじゃなくしていきましょう．そのためにこのようなことをして
いきます：</p>
<ul>
<li>車輪の再発明をやめる</li>
<li>どんな型も入れられるようにする</li>
<li>peekを実装する</li>
<li>イテレートできるようにする</li>
</ul>
<p>そして，これらを通じて以下のことを学んでいきましょう：</p>
<ul>
<li>Optionの応用</li>
<li>ジェネリクス</li>
<li>借用の寿命</li>
<li>イテレータ</li>
</ul>
<p><code>second.rs</code>という名前で新しいファイルを作りましょう:</p>
<pre><code class="language-rust ignore">// in lib.rs

pub mod first;
pub mod second;
</code></pre>
<p>そして<code>first.rs</code>の内容をまるごとコピーしてください．</p>
<h1><a class="header" href="#optionを使う" id="optionを使う">Optionを使う</a></h1>
<p>特別目ざとい人は私達が劣化Optionを再発明したことに気づいたかもしれません：</p>
<pre><code class="language-rust ignore">enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}
</code></pre>
<p>Linkは<code>Option&lt;Box&lt;Node&gt;&gt;</code>と同じことです．かといって<code>Option&lt;Box&lt;Node&gt;&gt;</code>を
どこにでも書くのは気が引けますし，<code>pop</code>の戻り値とは違いLinkは外部から
見ることはできないので，これをLinkと呼び続けることは問題なさそうです．
しかし，Optionには<em>超いい</em>メソッドがいくつもあり，Optionを使えば
（私達がやったように）それらを自力で実装することもありません．なので
全部Optionを使いましょう．まずは愚直に全部のMoreとEmptyをSomeとNoneに
書き換えていきましょう：</p>
<pre><code class="language-rust ignore">use std::mem;

pub struct List {
    head: Link,
}

// 型エイリアスです！イエーイ！
type Link = Option&lt;Box&lt;Node&gt;&gt;;

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: mem::replace(&amp;mut self.head, None),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match mem::replace(&amp;mut self.head, None) {
            None =&gt; None,
            Some(node) =&gt; {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = mem::replace(&amp;mut self.head, None);
        while let Some(mut boxed_node) = cur_link {
            cur_link = mem::replace(&amp;mut boxed_node.next, None);
        }
    }
}
</code></pre>
<p>これは若干良くなった程度ですが，さらなる良さがOptionのメソッドを使うことで
得られます．</p>
<p>まず<code>mem::replace(&amp;mut option, None)</code>はめっちゃよくある形で，
あまりにもよくあるのでOptionにはそのための<code>take</code>というメソッドがあります．</p>
<pre><code class="language-rust ignore">pub struct List {
    head: Link,
}

type Link = Option&lt;Box&lt;Node&gt;&gt;;

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match self.head.take() {
            None =&gt; None,
            Some(node) =&gt; {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
</code></pre>
<p>次に<code>match option { None =&gt; None, Some(x) =&gt; Some(y) }</code>もめっちゃよくある形で，
あまりにもよくあるので<code>map</code>というメソッドがあります．<code>map</code>には<code>Some(x)</code>の<code>x</code>
から<code>Some(y)</code>の<code>y</code>を作る関数を渡す必要があります．<code>fn</code>で関数を宣言して渡す
のもいいですが，<em>インラインで</em>書くほうがいいでしょう．</p>
<p>そのためには<em>クロージャ</em>を使います．クロージャは，クロージャ外のローカル変数を
参照することができる無名関数です．この強力な機能によって，条件に依存する処理を
超簡単に書くことができます．<code>match</code>を使っているのは<code>pop</code>だけですね．書き換えて
みましょう：</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    self.head.take().map(|node| {
        self.head = node.next;
        node.elem
    })
}
</code></pre>
<p>アーイイ．今回の変更で何もぶっ壊れてないことを確認しましょう：</p>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 2 tests
test first::test::basics ... ok
test second::test::basics ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>いいですね！次はコードの<em>挙動</em>を改善していきましょう！</p>
<h1><a class="header" href="#あらゆるものをジェネリックにする" id="あらゆるものをジェネリックにする">あらゆるものをジェネリックにする</a></h1>
<p>OptionとBoxですこしだけジェネリクスには触れました．しかし，これまでは
なんとかジェネリックな要素を持つ型を宣言することは避けることができていました．</p>
<p>実はジェネリック型の宣言はとても簡単です．とりあえず全部ジェネリックにしましょう：</p>
<pre><code class="language-rust ignore">pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
</code></pre>
<p>コードに若干とげとげを追加することで唐突にジェネリックになりました．もちろん
これ<em>だけ</em>ではだめです．コンパイラにバチクソ怒られるでしょう．</p>
<pre><code class="language-text">&gt; cargo test

error[E0107]: wrong number of type arguments: expected 1, found 0
  --&gt; src/second.rs:14:6
   |
14 | impl List {
   |      ^^^^ expected 1 type argument

error[E0107]: wrong number of type arguments: expected 1, found 0
  --&gt; src/second.rs:36:15
   |
36 | impl Drop for List {
   |               ^^^^ expected 1 type argument

</code></pre>
<p>ここでの問題は明らかです．私達はこの<code>List</code>とかいうのを扱っていますが，そんなものは
もう存在しません．OptionやBoxのように，常に<code>List&lt;何か&gt;</code>を扱わなくてはいけないのです．</p>
<p>しかしこのimplに渡す何かとは何でしょうか？List同様，<em>全て</em>のコードがTに対して
動いてほしいですよね．ではListと同じく<code>impl</code>もとげとげにしましょう：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|node| {
            self.head = node.next;
            node.elem
        })
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
</code></pre>
<p>...そしてこれで終わりです！</p>
<pre><code>&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 2 tests
test first::test::basics ... ok
test second::test::basics ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>私達のコードはこれで完全に任意の型Tについてジェネリックになりました．いやマジ
Rust<em>楽勝</em>だな．ここで一切の変更が加えられていない<code>new</code>に注目してみましょう：</p>
<pre><code class="language-rust ignore">pub fn new() -&gt; Self {
    List { head: None }
}
</code></pre>
<p>リファクタリングとコピペの守護神，Selfの栄光を讃えましょう．Listを生成する際
<code>List&lt;T&gt;</code>と書いていないことにも注目してください．<code>List&lt;T&gt;</code>を返す関数の戻り値
であることから，関数を呼んだ側からTの型が推論されます．</p>
<p>さて，次は全く新しい<em>処理</em>を書いていきましょう！</p>
<h1><a class="header" href="#peek" id="peek">Peek</a></h1>
<p>前回実装する気もなかった機能はpeek<sup class="footnote-reference"><a href="#1">1</a></sup>です．これをやっていきましょう．やること
といえば，リストのheadがあるときその参照を返せばいいだけです．簡単そうですね．
やってみましょう：</p>
<pre><code class="language-rust ignore">pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.map(|node| {
        &amp;node.elem
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0515]: cannot return reference to local data `node.elem`
  --&gt; src/second.rs:37:13
   |
37 |             &amp;node.elem
   |             ^^^^^^^^^^ returns a reference to data owned by the current function

error[E0507]: cannot move out of borrowed content
  --&gt; src/second.rs:36:9
   |
36 |         self.head.map(|node| {
   |         ^^^^^^^^^ cannot move out of borrowed content


</code></pre>
<p>ハァ〜今度はなんだよ？</p>
<p>mapは<code>self</code>の値を取ってしまいますから，Optionの外に要素をムーブしてしまいます．
前回は<code>take</code>した直後だったのでそれでよかったのですが，今回は値を取っておきたいので
だめです．これに対処する<em>正しい</em>方法はOptionが持つ<code>as_ref</code>メソッドを使うことです．
<code>as_ref</code>のシグネチャはこんな感じです：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn as_ref(&amp;self) -&gt; Option&lt;&amp;T&gt;;
}
</code></pre>
<p>このメソッドはT型についてのOptionを，T型の参照についてのOptionに降格させます．
これをmatchで自前実装することもできますが<em>嫌です</em>ね．それをやろうとすると
Optionを剥がして詰め替えることをしなくてはいけません．幸いなことにそれは<code>.</code>
演算子がやってくれます．</p>
<pre><code class="language-rust ignore">pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.as_ref().map(|node| {
        &amp;node.elem
    })
}
</code></pre>
<pre><code class="language-text">cargo build

    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
</code></pre>
<p>はいバッチリ</p>
<p>これの<em>可変</em>バージョンを<code>as_mut</code>で作ることもできます：</p>
<pre><code class="language-rust ignore">pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    self.head.as_mut().map(|node| {
        &amp;mut node.elem
    })
}
</code></pre>
<pre><code class="language-text">lists::cargo build

</code></pre>
<p>楽勝か？</p>
<p>テストも忘れず書きましょう：</p>
<pre><code class="language-rust ignore">#[test]
fn peek() {
    let mut list = List::new();
    assert_eq!(list.peek(), None);
    assert_eq!(list.peek_mut(), None);
    list.push(1); list.push(2); list.push(3);

    assert_eq!(list.peek(), Some(&amp;3));
    assert_eq!(list.peek_mut(), Some(&amp;mut 3));
}
</code></pre>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 3 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::peek ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>いいですね．しかし，これでは<code>peek_mut</code>で取った値が本当に可変かどうか
わかりませんよね？値が可変だとしても、誰も変更しなかったら可変性をテストしたと
本当に言えるでしょうか？返り値の<code>Option&lt;&amp;mut T&gt;</code>に<code>map</code>を使って全然違う値を
突っ込んでみましょう：</p>
<pre><code class="language-rust ignore">#[test]
fn peek() {
    let mut list = List::new();
    assert_eq!(list.peek(), None);
    assert_eq!(list.peek_mut(), None);
    list.push(1); list.push(2); list.push(3);

    assert_eq!(list.peek(), Some(&amp;3));
    assert_eq!(list.peek_mut(), Some(&amp;mut 3));
    list.peek_mut().map(|&amp;mut value| {
        value = 42
    });

    assert_eq!(list.peek(), Some(&amp;42));
    assert_eq!(list.pop(), Some(42));
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

error[E0384]: cannot assign twice to immutable variable `value`
   --&gt; src/second.rs:100:13
    |
99  |         list.peek_mut().map(|&amp;mut value| {
    |                                   -----
    |                                   |
    |                                   first assignment to `value`
    |                                   help: make this binding mutable: `mut value`
100 |             value = 42
    |             ^^^^^^^^^^ cannot assign twice to immutable variable          ^~~~~
</code></pre>
<p>コンパイラは<code>value</code>が不変だと言って怒っています．でも明らかに<code>&amp;mut value</code>って
書いてますよね．どゆこと？実はこの書き方はクロージャの引数が可変参照であることを
指定していることにならないのです．そうではなく，引数に対してマッチするパターンを
指定していることになります．<code>|&amp;mut value|</code>は「この引数は可変参照だけど，こいつの
値をコピーして<code>value</code>に入れてね」という意味になります．<code>|value|</code>と書くことで
<code>value</code>の型を<code>&amp;mut i32</code>にでき，headを変更できるようになります：</p>
<pre><code class="language-rust ignore">    #[test]
    fn peek() {
        let mut list = List::new();
        assert_eq!(list.peek(), None);
        assert_eq!(list.peek_mut(), None);
        list.push(1); list.push(2); list.push(3);

        assert_eq!(list.peek(), Some(&amp;3));
        assert_eq!(list.peek_mut(), Some(&amp;mut 3));

        list.peek_mut().map(|value| {
            *value = 42
        });

        assert_eq!(list.peek(), Some(&amp;42));
        assert_eq!(list.pop(), Some(42));
    }
</code></pre>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 3 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::peek ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>かなり良くなりましたね！</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>訳注：スタックの一番上の要素をpopせずに取得する（覗き見る）機能</p>
</div>
<h1><a class="header" href="#intoiter" id="intoiter">IntoIter</a></h1>
<p>Rustでは要素の集まりをイテレートするときには<em>Iterator</em>トレイトを使います．
このトレイトは<code>Drop</code>よりも若干複雑です：</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
</code></pre>
<p>ここで<code>type Item</code>というブロックが新しく出てきました．これはIteratorを実装する
型には<em>関連付けられた型</em>があることを表しています．この場合<code>next</code>したときに
出てくる型のことです．</p>
<p>nextが<code>Option&lt;Self::Item&gt;</code>を返す理由は，このメソッドが<code>has_next</code>と<code>get_next</code>の
役割を併せ持つからです．もし次の値があれば<code>Some(value)</code>を返し，なければ<code>None</code>を
返すわけです．これによって，より人間工学的で安全なAPIを構築しつつ<code>has_next</code>と
<code>get_next</code>を別々に実装した際の冗長さを回避できるのです．うまい手ですね！</p>
<p>悲しいことにRustには（まだ）<code>yield</code>文のようなものはありません．なのでそれに
相当する処理を自力で実装する必要があります．さらに，実はイテレータには
3つの種類があり，それぞれを実装しなくてはいけません：</p>
<ul>
<li>IntoIter - <code>T</code></li>
<li>IterMut - <code>&amp;mut T</code></li>
<li>Iter - <code>&amp;T</code></li>
</ul>
<p>実はIntoIterを実装するために必要なものはすでに揃っています．ただ<code>pop</code>を
呼びまくればいいだけです．IntoIterをListのラッパーとして，こんな感じに
実装できます：</p>
<pre><code class="language-rust ignore">// タプル構造体はstructの変化形の一つです
// 他の型のラッパーを作るときに便利
pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // タプル構造体のフィールドには数字でアクセス
        self.0.pop()
    }
}
</code></pre>
<p>そしてテストを書きましょう：</p>
<pre><code class="language-rust ignore">#[test]
fn into_iter() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.into_iter();
    assert_eq!(iter.next(), Some(3));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next(), Some(1));
    assert_eq!(iter.next(), None);
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 4 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::peek ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>いい感じですね！</p>
<h1><a class="header" href="#iter" id="iter">Iter</a></h1>
<p>さて，ではIterを実装していきましょう．今回はすでにある実装に頼るわけには
いかないので，自らの手で実装しましょう．基本的な処理は，次に返したいノード
の一つ前のノードのポインタを握り続けることです．というのも，次に返したい
ノードが存在しないかもしれないからです（リストが空か，最後の要素を返した後
そういうことになります）．参照はOptionである必要がありますね．要素を返したら
そのノードの<code>next</code>にポインタを移す処理が要ります．</p>
<p>よし，やってみましょう：</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;T&gt; {
    next: Option&lt;&amp;Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.map(|node| &amp;node) }
    }
}

impl&lt;T&gt; Iterator for Iter&lt;T&gt; {
    type Item = &amp;T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;node);
            &amp;node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0106]: missing lifetime specifier
  --&gt; src/second.rs:72:18
   |
72 |     next: Option&lt;&amp;Node&lt;T&gt;&gt;,
   |                  ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
  --&gt; src/second.rs:82:17
   |
82 |     type Item = &amp;T;
   |                 ^ expected lifetime parameter
</code></pre>
<p>ああ，ライフタイムね...．ライフタイムについては聞いたことがあります．
悪夢のような代物だと言う話ですが．</p>
<p>ちょっと新しいことをやってみましょう．<code>error[E0106]</code>っていうのがありますね？
これはコンパイラエラーコードです．これが何なのかrustcに聞くことができるオプション
が，えっと，<code>--explain</code>です：</p>
<pre><code class="language-text">&gt; rustc --explain E0106
This error indicates that a lifetime is missing from a type. If it is an error
inside a function signature, the problem may be with failing to adhere to the
lifetime elision rules (see below).

Here are some simple examples of where you'll run into this error:

struct Foo { x: &amp;bool }        // error
struct Foo&lt;'a&gt; { x: &amp;'a bool } // correct

enum Bar { A(u8), B(&amp;bool), }        // error
enum Bar&lt;'a&gt; { A(u8), B(&amp;'a bool), } // correct

type MyStr = &amp;str;        // error
type MyStr&lt;'a&gt; = &amp;'a str; //correct
...

</code></pre>
<p>これは，その...あんまり助けになりませんね（このドキュメントは私達がいま持っている
より深いRustへの理解を要求しています）でもこの<code>'a</code>っていうのをstructにつければ
良さそうに見えますね？やってみましょう．</p>
<pre><code>pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0106]: missing lifetime specifier
  --&gt; src/second.rs:83:22
   |
83 | impl&lt;T&gt; Iterator for Iter&lt;T&gt; {
   |                      ^^^^^^^ expected lifetime parameter

error[E0106]: missing lifetime specifier
  --&gt; src/second.rs:84:17
   |
84 |     type Item = &amp;T;
   |                 ^ expected lifetime parameter

error: aborting due to 2 previous errors
</code></pre>
<p>なるほど，だんだんパターンが見えてきました．このちっこいのをあらゆるところに
つけまくってみましょう：</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;'a, T&gt; List&lt;T&gt; {
    pub fn iter(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.map(|node| &amp;'a node) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;
    fn next(&amp;'a mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;'a node);
            &amp;'a node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error: expected `:`, found `node`
  --&gt; src/second.rs:77:47
   |
77 |         Iter { next: self.head.map(|node| &amp;'a node) }
   |         ---- while parsing this struct        ^^^^ expected `:`

error: expected `:`, found `node`
  --&gt; src/second.rs:85:50
   |
85 |             self.next = node.next.map(|node| &amp;'a node);
   |                                                  ^^^^ expected `:`

error[E0063]: missing field `next` in initializer of `second::Iter&lt;'_, _&gt;`
  --&gt; src/second.rs:77:9
   |
77 |         Iter { next: self.head.map(|node| &amp;'a node) }
   |         ^^^^ missing `next`
</code></pre>
<p>あーっ．Rustが壊れてしまいました．</p>
<p>多分この<code>'a</code>が一体何を意味するのか知る必要がありそうです．</p>
<p>ライフタイムは沢山の人々を恐怖によって遠ざけてきました．プログラミングの
黎明から私達が慣れ親しんできた概念を変えてしまうからです．これまでは
なんとかライフタイムから逃れ続けてくることができましたが，実はこれまでもずっと
私達のプログラムに絡みついていたのです．</p>
<p>ライフタイムはガベージコレクションを持つ言語には必要のないものです．ガベージコレクタ―
が魔法のように全ての寿命を管理してくれるからです．Rustではほとんどのデータが
<em>手動で</em>管理されるため，別のやり方が必要でした．CとC++から，人間にポインタを
与えて管理させると制御不能のメモリ不安全性がはびこることがすでに分かっています．
この不安全性の原因はおおむね次の2種類の誤りに分類できます：</p>
<ul>
<li>スコープ外に出た物のポインタを持ち続ける</li>
<li>変更されてしまった物のポインタを持ち続ける</li>
</ul>
<p>ライフタイムはどちらの問題も解決し，99%の場合透過的に処理してくれます．</p>
<p>で，ライフタイムとはなんでしょうか？</p>
<p>簡単に言うと，コードの中の特定の領域（ブロックやスコープ）のことです．終わり．
借用がライフタイムに紐付けられたとき，その借用はそのライフタイムの<em>あいだじゅう</em>有効
でなくてはならないことを表しています．様々な条件によって借用がどのくらい生存
しなくてはいけないか，また生存できるかが決まります．とどのつまりライフタイムという
仕組みは，それらの条件の中で借用の寿命を最小化する制約ソルバなのです．もし
すべての条件を満たすライフタイムが見つかれば，コンパイルが通ります！さもなければ，
何かの寿命が足りないというエラーが返ってくるでしょう．</p>
<p>一般に，関数内でのライフタイムについて言及する必要はありませんし，<em>何があっても</em>
言及したくないはずです．コンパイラは全ての借用の寿命を知っていて，ちゃんと
最小のライフタイムを見つけることができます．しかしAPIレベルではコンパイラは
十分な情報を持って<em>いません</em>．なので人間がライフタイムどうしの関係を手動で教えて
あげる必要があるのです．</p>
<p>原則としては，依存パッケージも含めてライフタイムをチェックすれば人間が教える必要も
ない<em>はず</em>です．しかしそのようなチェックは膨大な処理が必要なうえ，別パッケージ
からのエラーを生み出して精神を破壊します．Rustは全ての借用を関数ごとに独立に
チェックし，全てのエラーをローカルからのものにとどめています（さもなければ
あなたが宣言した型のシグネチャが誤っています）．</p>
<p>そういえば過去のコードで，借用を関数のシグネチャに書いたのにライフタイムを指定して
いないことがありましたね．実はあれはOKです！これはRustがライフタイムを自動で割り当てて
くれるよくあるケースで，<em>ライフタイムの省略</em>と呼ばれています．</p>
<p>具体的にいうとこうです：</p>
<pre><code class="language-rust ignore">// 入力が一つしかないので出力のライフタイムはその一つしかない入力に依存すると推測する
fn foo(&amp;A) -&gt; &amp;B; // これは次と同じ：
fn foo&lt;'a&gt;(&amp;'a A) -&gt; &amp;'a B;

// たくさんある入力はそれぞれ独立のライフタイムだと推測する
fn foo(&amp;A, &amp;B, &amp;C); // これは次と同じ：
fn foo&lt;'a, 'b, 'c&gt;(&amp;'a A, &amp;'b B, &amp;'c C);

// メソッドの出力は`self`と同じだと推測する
fn foo(&amp;self, &amp;B, &amp;C) -&gt; &amp;D; // これは次と同じ：
fn foo&lt;'a, 'b, 'c&gt;(&amp;'a self, &amp;'b B, &amp;'c C) -&gt; &amp;'a D;
</code></pre>
<p>で<code>fn foo&lt;'a&gt;(&amp;'a A) -&gt; &amp;'a B</code>は何を<em>意味する</em>のでしょうか？これは要するに
fooの引数は少なくとも返り値より長いライフタイムを持たなくてはいけないことを
意味しています．つまり，fooの返り値をずっと引き回した場合，引数に与えた
借用もずっと生存していなくてはいけません．返り値を使うのをやめたとき，
コンパイラは引数も解放して大丈夫と判断します．</p>
<p>この仕組みがあることで，なにかのメモリ割り当てが解放された後に使われることも，
なにかが借用されているのに変更されることも防ぐことができます．逆に言えば
この仕組みを守るだけでそれを達成できるのです！</p>
<p>さて，ではIterに話を戻しましょう．</p>
<p>ライフタイムがないバージョンに戻しましょう：</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;T&gt; {
    next: Option&lt;&amp;Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.map(|node| &amp;node) }
    }
}

impl&lt;T&gt; Iterator for Iter&lt;T&gt; {
    type Item = &amp;T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;node);
            &amp;node.elem
        })
    }
}
</code></pre>
<p>ライフタイムをつけなくてはいけないのは関数と型のシグネチャです：</p>
<pre><code class="language-rust ignore">// Iterは*何らかの*ライフタイムに対してジェネリックですが，それが何かはどうでもいいです
pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

// Listには紐づくライフタイムはないのでライフタイムパラメータなし
impl&lt;T&gt; List&lt;T&gt; {
    // iterに使われる*まさにその*借用のためにライフタイムを宣言しました
    // これで&amp;selfはIterが生きる限り生き続ける必要があります
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.map(|node| &amp;node) }
    }
}

// Iterにつける必要があるのでライフタイムは要ります
impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    // 型宣言なのでここにも要ります
    type Item = &amp;'a T;

    // 上述のシュガーがあるのでここはライフタイムをつけなくても大丈夫です
    // Selfは相変わらずめっちゃ最高
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;node);
            &amp;node.elem
        })
    }
}
</code></pre>
<p>おし，今回はうまく行くと思います．</p>
<pre><code class="language-text">cargo build

error[E0308]: mismatched types
  --&gt; src/second.rs:77:22
   |
77 |         Iter { next: self.head.map(|node| &amp;node) }
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `second::Node`, found struct `std::boxed::Box`
   |
   = note: expected type `std::option::Option&lt;&amp;second::Node&lt;T&gt;&gt;`
              found type `std::option::Option&lt;&amp;std::boxed::Box&lt;second::Node&lt;T&gt;&gt;&gt;`

error[E0308]: mismatched types
  --&gt; src/second.rs:85:25
   |
85 |             self.next = node.next.map(|node| &amp;node);
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `second::Node`, found struct `std::boxed::Box`
   |
   = note: expected type `std::option::Option&lt;&amp;'a second::Node&lt;T&gt;&gt;`
              found type `std::option::Option&lt;&amp;std::boxed::Box&lt;second::Node&lt;T&gt;&gt;&gt;`
</code></pre>
<p>(╯°□°)╯︵ ┻━┻</p>
<p>OK．ライフタイムのエラーは直りましたが別の型エラーが出てきました．</p>
<p><code>&amp;Node</code>を保存したいのに<code>&amp;Box&lt;Node&gt;</code>が返っていると．OK．簡単です．借用の前にBox
を外せばいいわけですね：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.map(|node| &amp;*node) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.map(|node| &amp;*node);
            &amp;node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (/Users/ABeingessner/dev/temp/lists)
error[E0515]: cannot return reference to local data `*node`
  --&gt; src/second.rs:77:43
   |
77 |         Iter { next: self.head.map(|node| &amp;*node) }
   |                                           ^^^^^^ returns a reference to data owned by the current function

error[E0507]: cannot move out of borrowed content
  --&gt; src/second.rs:77:22
   |
77 |         Iter { next: self.head.map(|node| &amp;*node) }
   |                      ^^^^^^^^^ cannot move out of borrowed content

error[E0515]: cannot return reference to local data `*node`
  --&gt; src/second.rs:85:46
   |
85 |             self.next = node.next.map(|node| &amp;*node);
   |                                              ^^^^^^ returns a reference to data owned by the current function

error[E0507]: cannot move out of borrowed content
  --&gt; src/second.rs:85:25
   |
85 |             self.next = node.next.map(|node| &amp;*node);
   |                         ^^^^^^^^^ cannot move out of borrowed content
</code></pre>
<p>(ﾉಥ益ಥ）ﾉ﻿ ┻━┻</p>
<p><code>as_ref</code>を忘れてました．そのせいでBoxを<code>map</code>にムーブしてしまい，値がドロップされ，
借用がもとの値を失ってしまったのです：</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;*node) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &amp;*node);
            &amp;node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (/Users/ABeingessner/dev/temp/lists)
error[E0308]: mismatched types
  --&gt; src/second.rs:77:22
   |
77 |         Iter { next: self.head.as_ref().map(|node| &amp;*node) }
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `second::Node`, found struct `std::boxed::Box`
   |
   = note: expected type `std::option::Option&lt;&amp;second::Node&lt;T&gt;&gt;`
              found type `std::option::Option&lt;&amp;std::boxed::Box&lt;second::Node&lt;T&gt;&gt;&gt;`

error[E0308]: mismatched types
  --&gt; src/second.rs:85:25
   |
85 |             self.next = node.next.as_ref().map(|node| &amp;*node);
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `second::Node`, found struct `std::boxed::Box`
   |
   = note: expected type `std::option::Option&lt;&amp;'a second::Node&lt;T&gt;&gt;`
              found type `std::option::Option&lt;&amp;std::boxed::Box&lt;second::Node&lt;T&gt;&gt;&gt;`

</code></pre>
<p>😭</p>
<p><code>as_ref</code>を使ったのでもう一段参照外しが必要になりました：</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &amp;**node);
            &amp;node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">cargo build

</code></pre>
<p>🎉 🎉 🎉</p>
<p>きっと「うわ，この<code>&amp;**</code>とかいうのはマジでカスだな」と思ってることでしょう．あなたの
感性は正しいです．通常Rustは<em>参照外し型強制</em>という機能でこういった操作を暗黙に
やってくれます．参照外し型強制がすることは，基本的には*をコード中に入れて型が
合うようにすることです．借用チェッカがあるため，ポインタがぐちゃぐちゃになって
いないことが分かっているのでこういうことができるのです！</p>
<p>しかし，今回の場合<code>&amp;T</code>ではなく<code>Option&lt;&amp;T&gt;</code>を使っていますね．これは参照外し型強制
が適用されるには複雑すぎるのです．私の経験上，このような形は幸運にもあまりありません．</p>
<p>完璧を期すために，<em>ターボフィッシュ</em>を使って<em>さらに</em>型のヒントを与えることができます：</p>
<pre><code class="language-rust ignore">    self.next = node.next.as_ref().map::&lt;&amp;Node&lt;T&gt;, _&gt;(|node| &amp;node);
</code></pre>
<p>mapの実装を見ると，このようにジェネリックになっています：</p>
<pre><code class="language-rust ignore">pub fn map&lt;U, F&gt;(self, f: F) -&gt; Option&lt;U&gt;
</code></pre>
<p>ターボフィッシュ（<code>::&lt;&gt;</code>）によって，コンパイラにmapがどの型を使えばいいか
教えることができます．この場合<code>::&lt;&amp;Node&lt;T&gt;, _&gt;</code>によって，「<code>&amp;Node&lt;T&gt;</code>を返してね，
でも他の型はどうでもいい」ということを言っています．</p>
<p>すると今度はコンパイラは<code>&amp;node</code>に参照外し型強制が適用できることがわかるので
いちいち*をつける必要がなくなります！</p>
<p>でもこれはあんまり大きな進歩とは言えなそうですね．参照外し型強制とたまには使える
ターボフィッシュを使いたい言い訳です😅</p>
<p>テストを書いて，動かなくなったりとにかく悪いことが起こったりしていないことを確認
しましょう：</p>
<pre><code class="language-rust ignore">#[test]
fn iter() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.iter();
    assert_eq!(iter.next(), Some(&amp;3));
    assert_eq!(iter.next(), Some(&amp;2));
    assert_eq!(iter.next(), Some(&amp;1));
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 5 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::peek ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>イエ〜ィ．</p>
<p>最後に，ここのライフタイムを省略できることに触れておきます：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }
}
</code></pre>
<p>これは次のコードと同じです：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }
}
</code></pre>
<p>やった―！ライフタイムが減りました！</p>
<p>もしライフタイムが実際にはあるのに省略することが気になるのであれば，
Rust2018の新機能，「ライフタイム省略明示」記号，<code>'_</code>を使うこともできます：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }
}
</code></pre>
<h1><a class="header" href="#itermut" id="itermut">IterMut</a></h1>
<p>正直に言います．IterMutは<em>治安が悪い</em>です．この言葉自体が治安悪いですが，
IterMutはIterと明らかに同じものです！</p>
<p>意味的にはそうですが，参照の基本に忠実に実装するとIterMutはガチの魔法になり，
それに比べればIterは児戯に等しいと言えます．</p>
<p>私達がIterのために実装したIteratorに注目してください：</p>
<pre><code class="language-rust ignore">impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { /* stuff */ }
}
</code></pre>
<p>これはこのように書きかえることができます：</p>
<pre><code class="language-rust ignore">impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next&lt;'b&gt;(&amp;'b mut self) -&gt; Option&lt;&amp;'a T&gt; { /* stuff */ }
}
</code></pre>
<p><code>next</code>の入力のライフタイムと出力のライフタイムの間には<em>何の</em>関係もありません．
なぜそんなことを気にするのでしょう？これのおかげで<code>next</code>を無条件に呼びまくる
ことができるからです！</p>
<pre><code class="language-rust ignore">let mut list = List::new();
list.push(1); list.push(2); list.push(3);

let mut iter = list.iter();
let x = iter.next().unwrap();
let y = iter.next().unwrap();
let z = iter.next().unwrap();
</code></pre>
<p>いいですね！</p>
<p>共有参照を使うなら<em>間違いなく</em>これでOKです．共有参照はいくつでも持つことができるからです．
しかし可変参照は同時に複数存在できません．</p>
<p>結局安全なコードを使う限り（この言葉の意味はまだ分かりませんが...）IterMutを実装するのは
とてつもなく困難なのです．ところが驚くべきことにIterMutは大抵のstructに対し全くもって
安全に実装することができます！</p>
<p>とりあえずIterのコードをコピーしてきて，全部可変にするところから始めましょう：</p>
<pre><code class="language-rust ignore">pub struct IterMut&lt;'a, T&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter_mut(&amp;self) -&gt; IterMut&lt;'_, T&gt; {
        IterMut { next: self.head.as_mut().map(|node| &amp;mut **node) }
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_mut().map(|node| &amp;mut **node);
            &amp;mut node.elem
        })
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
error[E0596]: cannot borrow `self.head` as mutable, as it is behind a `&amp;` reference
  --&gt; src/second.rs:95:25
   |
94 |     pub fn iter_mut(&amp;self) -&gt; IterMut&lt;'_, T&gt; {
   |                     ----- help: consider changing this to be a mutable reference: `&amp;mut self`
95 |         IterMut { next: self.head.as_mut().map(|node| &amp;mut **node) }
   |                         ^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

error[E0507]: cannot move out of borrowed content
   --&gt; src/second.rs:103:9
    |
103 |         self.next.map(|node| {
    |         ^^^^^^^^^ cannot move out of borrowed content
</code></pre>
<p>この上下のエラーは別々のもののようです．一つ目はどうやって直すか書いてありますし簡単そうですね！
共有参照を可変参照に昇格させることはできないので<code>iter_mut</code>は<code>&amp;mut self</code>を引数にとらなくては
いけません．ただのコピペミスですね．</p>
<pre><code class="language-rust ignore">pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;'_, T&gt; {
    IterMut { next: self.head.as_mut().map(|node| &amp;mut **node) }
}
</code></pre>
<p>もう一つのエラーはなんでしょうか？</p>
<p>おっと！前章の<code>iter</code>のコードにバグがあったものの，幸いにも動いていたようです！</p>
<p>私達はCopyの魔法を初めて目の当たりにしています．私達が<a href="first-ownership.html">所有権</a>を使い始めたとき，
ムーブされてしまったものは使えないと言いました．幾つかの型に対しては，これは筋の通った
挙動です．かしこいBoxくんはムーブした変数のヒープの割当を2つに増やしたりはしません．</p>
<p>しかし他の型については，この挙動は<em>ゴミ</em>です．例えば整数はただの数であり，所有権もクソも
ありません．そこで，整数型はCopy型のひとつに入れられています．Copy型はビットごとのコピーに
よって元通りコピーできる型を指し，ムーブされたときでも元の変数を依然使用できるという強力な
特徴を持っています．同様にCopy型は，<code>mem::replace</code>などで代わりを用意しなくても参照から
取り出すことができるのです！</p>
<p>Rustの数値プリミティブ型（i32, u64, bool, f32, char, などなど）はCopy型です．
他の型も，構成要素が全てCopy型である限りCopy型にすることができます．</p>
<p>なぜIterのコードが動いていたかといえば，共有参照もCopy型だからです．そして<code>&amp;</code>がCopy型なので
<code>Option&lt;&amp;&gt;</code>もCopy型です．そして<code>self.next.map</code>したとき，Optionがコピーされるので
今回私達が出会ったエラーは出なかったというわけです．しかし今回はCopy型ではない<code>&amp;mut</code>を
使っているため（もし&amp;mutをコピーできたら同じメモリアドレスに2つの&amp;mutを持つことになって
しまいます），<code>take</code>でOptionの中身を取らないといけません．</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    self.next.take().map(|node| {
        self.next = node.next.as_mut().map(|node| &amp;mut **node);
        &amp;mut node.elem
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

</code></pre>
<p>えー...と，やりました！IterMutができました！</p>
<p>テストしてみましょう：</p>
<pre><code class="language-rust ignore">#[test]
fn iter_mut() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.iter_mut();
    assert_eq!(iter.next(), Some(&amp;mut 3));
    assert_eq!(iter.next(), Some(&amp;mut 2));
    assert_eq!(iter.next(), Some(&amp;mut 1));
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 6 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::iter_mut ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::peek ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>やった．うごいてますね．</p>
<p>マジか．</p>
<p>どういうことなの...</p>
<p>いや、ちゃんと動く<em>ように</em>実装してはいましたよ．でもいつも何かに邪魔されるんです！
ひとつはっきりさせておきましょう：</p>
<p>片方向連結リストの要素をひとつずつ，その可変参照を取得するコードを実装しました．そして
それが動くことも確認しました．コードは安全です．なにも治安の悪いことをしてません．</p>
<p>私に言わせれば，これは結構すごいことです．うまく行った理由はいくつかあります：</p>
<ul>
<li>私達は<code>Option&lt;&amp;mut&gt;</code>を<code>take</code>したので，排他的な可変参照を得ることができました．
これによって複数回参照される心配はなくなりました．</li>
<li>Rustは，可変参照であるstructのフィールドを切り離しても大丈夫なことをわかっています．
切り離されたフィールドから親をたどる手段がないからです．</li>
</ul>
<p>これらの事実から，今回IterMutを実装した設計を流用して安全な配列やツリーも実装できる
事がわかります！イテレータを双方向にして前と後ろから同時にイテレートすることすらできます！すごい！</p>
<h1><a class="header" href="#最終コード-1" id="最終コード-1">最終コード</a></h1>
<p>そんなこんなでこれが二つ目のリスト，その最終コードです！</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|node| {
            self.head = node.next;
            node.elem
        })
    }

    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| {
            &amp;node.elem
        })
    }

    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        self.head.as_mut().map(|node| {
            &amp;mut node.elem
        })
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;'_, T&gt; {
        IterMut { next: self.head.as_mut().map(|node| &amp;mut **node) }
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // タプル構造体のフィールドには数字でアクセス
        self.0.pop()
    }
}

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &amp;**node);
            &amp;node.elem
        })
    }
}

pub struct IterMut&lt;'a, T&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.take().map(|node| {
            self.next = node.next.as_mut().map(|node| &amp;mut **node);
            &amp;mut node.elem
        })
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // 空のリストが動くことを確認
        assert_eq!(list.pop(), None);

        // リストの要素をつめる
        list.push(1);
        list.push(2);
        list.push(3);

        // 普通に要素を削除してみる
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // 何も壊れてないことを確認するためにもう一回push
        list.push(4);
        list.push(5);

        // 普通に要素を削除してみる
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // リストを出し切ったとき
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);
    }

    #[test]
    fn peek() {
        let mut list = List::new();
        assert_eq!(list.peek(), None);
        assert_eq!(list.peek_mut(), None);
        list.push(1); list.push(2); list.push(3);

        assert_eq!(list.peek(), Some(&amp;3));
        assert_eq!(list.peek_mut(), Some(&amp;mut 3));

        list.peek_mut().map(|value| {
            *value = 42
        });

        assert_eq!(list.peek(), Some(&amp;42));
        assert_eq!(list.pop(), Some(42));
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next(), Some(1));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;1));
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter_mut();
        assert_eq!(iter.next(), Some(&amp;mut 3));
        assert_eq!(iter.next(), Some(&amp;mut 2));
        assert_eq!(iter.next(), Some(&amp;mut 1));
    }
}

#}</code></pre></pre>
<p>使えそうな感じになってきましたね！</p>
<h1><a class="header" href="#永続的な片方向スタック" id="永続的な片方向スタック">永続的な片方向スタック</a></h1>
<p>私達は片方向リストを完全に極めました．</p>
<p>単一の所有権だけでなく共有の所有権も扱うことにしましょう．<em>永続的な</em>片方向
リストを作るのです．関数型プログラマのみなさんがおなじみのリストはこれです．
リストの先頭<em>もしくは</em>末尾を取得できて，リストの先頭をを他のリストの末尾に
くっつけることができて...あとは...そのくらいですかね．不変性というのはヤバい
クスリですね．</p>
<p>この章の主眼はRcとArcと仲良くなることですが，同時に次章の<em>全く新しい</em>
リストに備える章でもあります．</p>
<p><code>third.rs</code>というファイルを加えましょう：</p>
<pre><code class="language-rust ignore">// in lib.rs

pub mod first;
pub mod second;
pub mod third;
</code></pre>
<p>今回は前のコードをコピペしません．無菌手術を執行します．</p>
<h1><a class="header" href="#設計" id="設計">設計</a></h1>
<p>では再び設計作業に入りましょう．</p>
<p>永続リストで最も重要なことはリストの末尾をほぼノーコストで操作できることです．</p>
<p>例えばこのような操作は永続リストではよくあることです：</p>
<pre><code class="language-text">list1 = A -&gt; B -&gt; C -&gt; D
list2 = tail(list1) = B -&gt; C -&gt; D
list3 = push(list2, X) = X -&gt; B -&gt; C -&gt; D
</code></pre>
<p>そして最終的にはメモリ上でこのような構造になっていてほしいのです：</p>
<pre><code class="language-text">list1 -&gt; A ---+
              |
              v
list2 ------&gt; B -&gt; C -&gt; D
              ^
              |
list3 -&gt; X ---+
</code></pre>
<p>これはBoxでは実現できません．なぜなら<code>B</code>が<em>共有参照</em>だからです．Bのメモリ割り当て
が解放されるときはどんなときでしょう？今list2を解放したらBは解放されるべきでしょうか？
Boxを使うならそうなって然るべきです！</p>
<p>関数型言語では--ほぼすべての言語でそうですが--これをガベージコレクションで解決
しています．ガベージコレクションの魔法のおかげでBが開放されるのはBを参照している
全てが解放された後です．うほほーい！</p>
<p>Rustにはガベージコレクションがない代わりに，<em>参照カウンタ</em>というものがあります．
参照カウンタは極めてシンプルなGCみたいなものです．大抵の場合トレーシングGCよりも
性能は著しく低いうえ，参照のループがあるとうまく動きません．でもこれしか
ないんだからしょうがないですね！幸い私達はループを作ることはないので（検証
してみてください．自信あります）大丈夫です．</p>
<p>ではどうすれば参照カウンタを使えるのでしょう？<code>Rc</code>です！RcはBoxのようなものですが，
複製することができ，そのメモリは参照が<em>全て</em>外されて<em>はじめて</em>解放されます．
不幸にもこの柔軟性の代償は高くつきます．というのは，Rcの中身の共有参照しか
得ることができないのです．つまり，Rcを使ったリストはデータを取り出すことも
変更することもできないのです．</p>
<p>ではどういう設計になるでしょうか？前回はこうでした：</p>
<pre><code class="language-rust ignore">pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
</code></pre>
<p>単にBoxをRcに変えるとどうでしょうか？</p>
<pre><code class="language-rust ignore">// in third.rs

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0412]: cannot find type `Rc` in this scope
 --&gt; src/third.rs:5:23
  |
5 | type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;
  |                       ^^ not found in this scope
help: possible candidate is found in another module, you can import it into scope
  |
1 | use std::rc::Rc;
  |
</code></pre>
<p>はいクソ．私達が今まで使ってきたものと違い，RcはRustのプログラムにデフォルトで
インポートされていないのでした．<em>雑魚が</em>．</p>
<pre><code class="language-rust ignore">use std::rc::Rc;
</code></pre>
<pre><code class="language-text">cargo build

warning: field is never used: `head`
 --&gt; src/third.rs:4:5
  |
4 |     head: Link&lt;T&gt;,
  |     ^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `elem`
  --&gt; src/third.rs:10:5
   |
10 |     elem: T,
   |     ^^^^^^^

warning: field is never used: `next`
  --&gt; src/third.rs:11:5
   |
11 |     next: Link&lt;T&gt;,
   |     ^^^^^^^^^^^^^
</code></pre>
<p>大丈夫そうですね．Rustは相変わらずどうでもいいことをいちいち指摘していますが．
でもこれはBoxをRcに書き換えて全部終わりにできそうですね！</p>
<p>...</p>
<p>だめです．そうは問屋がおろしません．</p>
<h1><a class="header" href="#基本" id="基本">基本</a></h1>
<p>Rustの基本についてはすでにだいぶ分かっていますので，簡単なコードをもう一度書く
ことは造作もありません．</p>
<p>コンストラクタはコピペで十分です：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }
}
</code></pre>
<p>今回は<code>push</code>と<code>pop</code>は意味をなしません．代わりにだいたい同じ機能の<code>append</code>
と<code>tail</code>を実装しましょう．</p>
<p>リストに要素を追加する<code>append</code>から始めましょう．この関数はリストと要素を
一つずつとり，それらをくっつけたリストを返します．可変のリストのとき同様
新しいノードを作りたいわけですが，そのノードの<code>next</code>は元のリストを指している
必要があります．目新しいことは，どうやってもとのリストに変更を加えずに
<code>next</code>を取得するかということくらいです．</p>
<p>その答えはCloneトレイトです．Cloneはほぼ全ての型に対して実装されており，
元の参照から切り離された「元オブジェクトとだいたい同じもの」を得る手段を
提供しています．C++のコピーコンストラクタに似ていますが，暗黙的に呼ばれること
がない点が異なります．</p>
<p>特にRcはCloneを，参照カウントを増やすために使用しています．なのでRcを使う場合，
Boxをサブリストにムーブする代わりに，単に古いリストのheadをCloneすることになります．
headをmatchで取り出すことも必要ありません．なぜならOptionに実装されているCloneが
まさに私達がやりたいことをやってくれるからです．</p>
<p>よし，じゃあやってみましょう:</p>
<pre><code class="language-rust ignore">pub fn append(&amp;self, elem: T) -&gt; List&lt;T&gt; {
    List { head: Some(Rc::new(Node {
        elem: elem,
        next: self.head.clone(),
    }))}
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

warning: field is never used: `elem`
  --&gt; src/third.rs:10:5
   |
10 |     elem: T,
   |     ^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

warning: field is never used: `next`
  --&gt; src/third.rs:11:5
   |
11 |     next: Link&lt;T&gt;,
   |     ^^^^^^^^^^^^^
</code></pre>
<p>うわ．Rustはフィールドを使っているかどうかにめちゃくちゃこだわりますね．この
リストを使う人がフィールドを使ってるか知る手段がないと言っています．でも
ここまではよさそうです．</p>
<p><code>tail</code>は<code>append</code>と論理的に逆のことをします．リストを引数に取り，元のリストから
先頭の要素を除いたリストを返します．やっていることはリストの二つ目の要素があれば
それをCloneするということです．やってみましょう：</p>
<pre><code class="language-rust ignore">pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
    List { head: self.head.as_ref().map(|node| node.next.clone()) }
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0308]: mismatched types
  --&gt; src/third.rs:27:22
   |
27 |         List { head: self.head.as_ref().map(|node| node.next.clone()) }
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::rc::Rc`, found enum `std::option::Option`
   |
   = note: expected type `std::option::Option&lt;std::rc::Rc&lt;_&gt;&gt;`
              found type `std::option::Option&lt;std::option::Option&lt;std::rc::Rc&lt;_&gt;&gt;&gt;`
</code></pre>
<p>ふむ．ぶっ壊れましたね．<code>map</code>のクロージャは<code>Y</code>を返して欲しがっていますが，私達は
<code>Option&lt;Y&gt;</code>を返しています．幸いこれもOptionを使う上でよくあるパターンです．
<code>and_then</code>を使えばOptionを返すことができます．</p>
<pre><code class="language-rust ignore">pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
    List { head: self.head.as_ref().and_then(|node| node.next.clone()) }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

</code></pre>
<p>素敵．</p>
<p>これで<code>tail</code>ができました．多分一つ目の要素を返す<code>head</code>も作ったほうがいいでしょう．
これは<code>peek</code>と同じです：</p>
<pre><code class="language-rust ignore">pub fn head(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.as_ref().map(|node| &amp;node.elem )
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

</code></pre>
<p>やったぜ．</p>
<p>これだけの機能があればテストも書けそうです：</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let list = List::new();
        assert_eq!(list.head(), None);

        let list = list.append(1).append(2).append(3);
        assert_eq!(list.head(), Some(&amp;3));

        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;2));

        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;1));

        let list = list.tail();
        assert_eq!(list.head(), None);

        // tailが空のとき動くことを確認
        let list = list.tail();
        assert_eq!(list.head(), None);

    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 5 tests
test first::test::basics ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test third::test::basics ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>完璧！</p>
<p>Iterも可変のリストのときと全く同じです：</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &amp;**node);
            &amp;node.elem
        })
    }
}
</code></pre>
<pre><code class="language-rust ignore">#[test]
fn iter() {
    let list = List::new().append(1).append(2).append(3);

    let mut iter = list.iter();
    assert_eq!(iter.next(), Some(&amp;3));
    assert_eq!(iter.next(), Some(&amp;2));
    assert_eq!(iter.next(), Some(&amp;1));
}
</code></pre>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 7 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test second::test::into_iter ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>誰だ動的型付けのほうが簡単とか言ったバカは？</p>
<p>このリストにはIntoIterやIterMutは実装できないことに注意してください．私達は
要素への共有参照しか持ってません．</p>
<h1><a class="header" href="#drop-1" id="drop-1">Drop</a></h1>
<p>可変のリスト同様，このリストもdropが再帰する問題を抱えています．確かに
今回はそれほど大きな問題ではありません．リストの途中の<em>どこか</em>で他のリストに
参照されているノードがあればそこでdropが止まるからです．とはいえ，依然として
対処すべき問題であり，どうすればいいかは自明ではありません．前回はこうしました：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
</code></pre>
<p>問題はループの中のところです：</p>
<pre><code class="language-rust ignore">cur_link = boxed_node.next.take();
</code></pre>
<p>これはBoxの中のNodeを変更していますが，今回はRcを使っているのでそれはできません．
他のRcがこの同じノードを参照している可能性があり，私達は共有参照しか持っていません．</p>
<p>しかし，もし他の参照がないことがわかっていれば中のNodeをRcの外に出しても大丈夫な
<em>はず</em>です．そして，もし大丈夫でないとき，それはdropを止めるときであるという
ことを意味しています．</p>
<p>刮目してください．Rcにはまさにそのためのメソッド，<code>try_unwrap</code>があります：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut head = self.head.take();
        while let Some(node) = head {
            if let Ok(mut node) = Rc::try_unwrap(node) {
                head = node.next.take();
            } else {
                break;
            }
        }
    }
}
</code></pre>
<pre><code class="language-text">cargo test
   Compiling lists v0.1.0 (/Users/ABeingessner/dev/too-many-lists/lists)
    Finished dev [unoptimized + debuginfo] target(s) in 1.10s
     Running /Users/ABeingessner/dev/too-many-lists/lists/target/debug/deps/lists-86544f1d97438f1f

running 8 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>やった！
勝ち．</p>
<h1><a class="header" href="#arc" id="arc">Arc</a></h1>
<p>不変の連結リストを使う理由として，スレッド間でデータを共有したいというものがあります．
とどのつまり，諸悪の根源は共有された可変な参照なので，この問題を解決する方法として
<em>可変な</em>というところを永久に葬り去ってしまうという手があります．</p>
<p>私達のリストはこれっぽっちもスレッドセーフではありません．スレッドセーフにしたければ
参照カウントを<em>アトミックに</em>する必要があります．そうでなければ2つのスレッドが同時に
参照カウントをインクリメントしようとし，<em>片方だけが通る</em>ことがあり得ます．そうなれば
リストはまだ参照されているノードのメモリ割り当てを解放してしまうでしょう！</p>
<p>スレッドセーフにするためには<em>Arc</em>を使う必要があります．Arcはたった一つの特徴，
参照カウントがアトミックに変更される点を除いてRcと完全に同じものです．Rcで十分な場合には
これは若干の余分なオーバーヘッドを伴うので，ArcとRcのどちらも使えるようになっています．
私達がすべきことはRcを<code>std::sync::Arc</code>に変えるだけです．はい，もうスレッドセーフです．
終わり！</p>
<p>しかし，ひとつ面白い疑問が湧いてきます．どうすればある型がスレッドセーフかどうか
知ることができるでしょうか？私達は何かやらかしてしまったのでしょうか？</p>
<p>いいえ！Rustのスレッド安全性を脅かすことはできません！</p>
<p>なぜなら，Rustは<code>Send</code>と<code>Sync</code>という2つのトレイトを使って，スレッド安全性を
第一級の機能としてモデル化しているからです．</p>
<p>ある型は他のスレッドに安全に<em>ムーブ</em>できるとき<em>Send</em>を持ちます．また，複数のスレッド間で
<em>共有</em>できるとき<em>Sync</em>を持ちます．つまり<code>T</code>がSyncのとき<code>&amp;T</code>はSendです．ここで安全と
言っているのは<em>データ競合</em>を防げるという意味です（<em>競合状態</em>という，さらに一般的な
問題と取り違えないでください）．</p>
<p>この2つはマーカートレイトです．つまりインターフェースの実装はありません．ある型は
Sendであるかそうでないかの二択です．ほかのAPIが，ある型がSendであるかチェックしたり
して使われるものです．そしてSendでない型なら他のスレッドに送ることができなくなります！
すごい！</p>
<p>また，SendとSyncは型のフィールドが全てSendやSyncであるかどうかによって自動的に
付与されます．Copyのときと似ていますが，自分で付与することもできる点が違います．</p>
<p>ほぼ全ての型はSendでありSyncです．たいていの型は自分自身のデータを所有しており，
したがってSendです．また，たいていの型をスレッド間で共有する方法は共有参照を
取って不変にすることだけであり，したがってSyncです．</p>
<p>しかし，なかには<em>内部可変性</em>という特徴を持ち，これらの条件に当てはまらない型があります．
ここまで私達が見てきた可変性は<em>継承可変性</em>（もしくは外部可変性）とよばれるもので，
値の可変性がその入れ物から継承されているものでした．継承可変性を持つ型は，不変な値の
フィールドをなんとなく変更したりすることはできません．</p>
<p>内部可変性は違います．共有参照の中にあるものを変更できるのです．内部可変性はだいたい
2つに分けられます．単一スレッドでのみ動作するCellと，複数スレッドで動作するLockです．
Cellのほうが低コストで使えることは明らかですね．あとはLockと似た動作をするプリミティブ型，
atomicがあります．</p>
<p>で，こいつらがどうRcやArcと関係するのでしょうか？実はRcもArcも<em>参照カウント</em>のために
内部可変性を持っているのです．更に悪いことに参照カウントは全てのインスタンス間で
共有されているのです！RcはCellをつかっており，したがってスレッドセーフではありません．
Arcはatomicを使っているのでスレッドセーフです．とはいえ，もちろんArcの中に型を
突っ込むことでスレッドセーフにするようなことはできず，他の型と同じようにしか
スレッド安全性を得られません．</p>
<p>私はぜっっっっったいにatomicのメモリ設計やSendを自分で実装することについて話したく
ありません．言うまでもないことですが，Rustのスレッド安全性の話に入り込むほど話は
複雑になっていきます．Rustを普通に使う人は，そう動くもんだと思っていればこういった
ことについて考える必要はありません．</p>
<h1><a class="header" href="#最終コード-2" id="最終コード-2">最終コード</a></h1>
<p>不変のスタックについてはこれで全部です．だいぶリストの実装がうまくなってきましたね！</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None }
    }

    pub fn append(&amp;self, elem: T) -&gt; List&lt;T&gt; {
        List { head: Some(Rc::new(Node {
            elem: elem,
            next: self.head.clone(),
        }))}
    }

    pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
        List { head: self.head.as_ref().and_then(|node| node.next.clone()) }
    }

    pub fn head(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| &amp;node.elem)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut head = self.head.take();
        while let Some(node) = head {
            if let Ok(mut node) = Rc::try_unwrap(node) {
                head = node.next.take();
            } else {
                break;
            }
        }
    }
}

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &amp;**node);
            &amp;node.elem
        })
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let list = List::new();
        assert_eq!(list.head(), None);

        let list = list.append(1).append(2).append(3);
        assert_eq!(list.head(), Some(&amp;3));

        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;2));

        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;1));

        let list = list.tail();
        assert_eq!(list.head(), None);

        // tailが空のとき動くことを確認
        let list = list.tail();
        assert_eq!(list.head(), None);
    }

    #[test]
    fn iter() {
        let list = List::new().append(1).append(2).append(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;1));
    }
}
#}</code></pre></pre>
<h1><a class="header" href="#クソだけどメモリ安全な両端キュー" id="クソだけどメモリ安全な両端キュー">クソだけどメモリ安全な両端キュー</a></h1>
<p>Rcと内部可変性について触れたので，こんな興味深い考えが浮かんできます...Rcを使えば
値を変更することはできそうです．そしてもし<em>そうなら</em>，双方向リストを安全に実装
できるかもしれません！</p>
<p>この章では内部可変性に詳しくなりましょう．そして安全であることは必ずしも<em>正しい</em>ことを
意味しないことをツラい方法で学んでいくことになるでしょう．双方向リストはむずかしいし，
私はいつもどこかで何かを間違えます．</p>
<p><code>fourth.rs</code>というファイルを新しく作りましょう：</p>
<pre><code class="language-rust ignore">// in lib.rs

pub mod first;
pub mod second;
pub mod third;
pub mod fourth;
</code></pre>
<p>今回も無菌手術です．でも，いつもみたいに過去の章のロジックを使い回すこともあるでしょう．</p>
<p>免責事項：この章はダメな例の実演です．</p>
<h1><a class="header" href="#設計-1" id="設計-1">設計</a></h1>
<p>今回のキモは<code>RefCell</code>型です．RefCellの重要な部分はこの2つのメソッドです：</p>
<pre><code class="language-rust ignore">fn borrow(&amp;self) -&gt; Ref&lt;'_, T&gt;;
fn borrow_mut(&amp;self) -&gt; RefMut&lt;'_, T&gt;;
</code></pre>
<p><code>borrow</code>と<code>borrow_mut</code>の関係は<code>&amp;</code>と<code>&amp;mut</code>の関係と全く同じです． <code>borrow</code>は
好きなだけ呼ぶことができますが<code>borrow_mut</code>は排他的にしか呼べません．</p>
<p>RefCellはこの条件をコンパイルタイムではなくランタイムにチェックします．
もしルールが守られなければRefCellはパニックを起こし，プログラムは
クラッシュします．ところで，このRefとかRefMutとかいう型はなんでしょう？
これは基本的には借用のために使われるRcみたいなもので，これがスコープ外
に出るまでRefCellは借用されたままになります．これについては後で触れます．</p>
<p>そしてRcとRefCellを使えば私達は...ビビるほど冗長であちこち可変だしサイクルを
解放できないガベージコレクタを作れます！イエェェェェィ...</p>
<p>はい．今回は<em>双方向連結</em>でやっていきたいんでした．これはそれぞれのノードが
一つ前と一つ次のノードを指すポインタを持っていることを意味しています．更に
リスト自身ははじめのノードと最後のノードのポインタを持ちます．これによって
はじめの要素と最後の要素の<em>両方</em>に対して高速な挿入と削除が行えます．</p>
<p>なので，多分私達が作りたいのはこんな感じのものでしょう：</p>
<pre><code class="language-rust ignore">use std::rc::Rc;
use std::cell::RefCell;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
    prev: Link&lt;T&gt;,
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

warning: field is never used: `head`
 --&gt; src/fourth.rs:5:5
  |
5 |     head: Link&lt;T&gt;,
  |     ^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `tail`
 --&gt; src/fourth.rs:6:5
  |
6 |     tail: Link&lt;T&gt;,
  |     ^^^^^^^^^^^^^

warning: field is never used: `elem`
  --&gt; src/fourth.rs:12:5
   |
12 |     elem: T,
   |     ^^^^^^^

warning: field is never used: `next`
  --&gt; src/fourth.rs:13:5
   |
13 |     next: Link&lt;T&gt;,
   |     ^^^^^^^^^^^^^

warning: field is never used: `prev`
  --&gt; src/fourth.rs:14:5
   |
14 |     prev: Link&lt;T&gt;,
   |     ^^^^^^^^^^^^^
</code></pre>
<p>見てください！ビルドしました！未使用コードの警告はありますが
ビルドは通っています！ではこのコードを使っていきましょう．</p>
<h1><a class="header" href="#作る" id="作る">作る</a></h1>
<p>ではリストを作る処理からやっていきましょう．これは素直に実装できます．
<code>new</code>は相変わらず簡単で，単にNoneで埋めればいいだけです．ちょっと扱いにくく
なりつつあるのでNodeのコンストラクタも作ってしまいましょう：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Node&lt;T&gt; {
    fn new(elem: T) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {
        Rc::new(RefCell::new(Node {
            elem: elem,
            prev: None,
            next: None,
        }))
    }
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

**A BUNCH OF DEAD CODE WARNINGS BUT IT BUILT**
</code></pre>
<p>いえーい！</p>
<p>今度はリストの先頭に要素をpushする操作を書きましょう．双方向リストは
明らかに単方向リストより複雑なのでちょっと手間をかける必要があります．
単方向リストのときは関数を1行にすることもできましたが今回はそうは
いきません．</p>
<p>とくにリストが空の場合の境界条件に対処する必要があります．大抵の処理は
<code>head</code>と<code>tail</code>のどちらかのポインタを操作するだけでいいのですが，空リスト
がからむと<em>両方</em>を同時に操作する必要があります．</p>
<p>メソッドが機能しているかどうかチェックするには「それぞれのノードを指すポインタが
2つずつある」状態を保っているかを見ると簡単です．リストの間にあるノードは
1つ前と1つ後からのポインタがあり，リストの端のノードは片方がリスト自体からの
ポインタになりますよね．</p>
<p>やってみましょう：</p>
<pre><code class="language-rust ignore">pub fn push_front(&amp;mut self, elem: T) {
    // 新しいノードはリンクの個数が+2され，他は+0であればよい
    let new_head = Node::new(elem);
    match self.head.take() {
        Some(old_head) =&gt; {
            // 空でないリストなのでold_headをつなげる
            old_head.prev = Some(new_head.clone()); // +1 new_head
            new_head.next = Some(old_head);         // +1 old_head
            self.head = Some(new_head);             // +1 new_head, -1 old_head
            // 計：+2 new_head, +0 old_head -- OK!
        }
        None =&gt; {
            // 空リストなのでtailにセットする
            self.tail = Some(new_head.clone());     // +1 new_head
            self.head = Some(new_head);             // +1 new_head
            // 計：+2 new_head -- OK!
        }
    }
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0609]: no field `prev` on type `std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;`
  --&gt; src/fourth.rs:39:26
   |
39 |                 old_head.prev = Some(new_head.clone()); // +1 new_head
   |                          ^^^^ unknown field

error[E0609]: no field `next` on type `std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;`
  --&gt; src/fourth.rs:40:26
   |
40 |                 new_head.next = Some(old_head);         // +1 old_head
   |                          ^^^^ unknown field
</code></pre>
<p>はいはい，コンパイルエラーね．まずはね．まずは．</p>
<p>なんで<code>prev</code>と<code>next</code>を見れないのでしょうか？<code>Rc&lt;Node&gt;</code>だったときには動いていたので
<code>RefCell</code>が邪魔してそうです．</p>
<p>ドキュメントを見てみるのがいいでしょう．</p>
<p><em>&quot;rust refcell&quot;でググる</em></p>
<p><em><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">最初のリンクをクリック</a></em></p>
<blockquote>
<p>A mutable memory location with dynamically checked borrow rules</p>
<p>See the <a href="https://doc.rust-lang.org/std/cell/index.html">module-level documentation</a> for more.</p>
</blockquote>
<p><em>リンクをクリック</em></p>
<blockquote>
<p>Shareable mutable containers.</p>
<p>Values of the <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> types may be mutated through shared references (i.e.
the common <code>&amp;T</code> type), whereas most Rust types can only be mutated through unique (<code>&amp;mut T</code>)
references. We say that <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> provide 'interior mutability', in contrast
with typical Rust types that exhibit 'inherited mutability'.</p>
<p>Cell types come in two flavors: <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>. <code>Cell&lt;T&gt;</code> provides <code>get</code> and <code>set</code>
methods that change the interior value with a single method call. <code>Cell&lt;T&gt;</code> though is only
compatible with types that implement <code>Copy</code>. For other types, one must use the <code>RefCell&lt;T&gt;</code>
type, acquiring a write lock before mutating.</p>
<p><code>RefCell&lt;T&gt;</code> uses Rust's lifetimes to implement 'dynamic borrowing', a process whereby one can
claim temporary, exclusive, mutable access to the inner value. Borrows for <code>RefCell&lt;T&gt;</code>s are
tracked 'at runtime', unlike Rust's native reference types which are entirely tracked
statically, at compile time. Because <code>RefCell&lt;T&gt;</code> borrows are dynamic it is possible to attempt
to borrow a value that is already mutably borrowed; when this happens it results in thread
panic.</p>
<h1><a class="header" href="#when-to-choose-interior-mutability" id="when-to-choose-interior-mutability">When to choose interior mutability</a></h1>
<p>The more common inherited mutability, where one must have unique access to mutate a value, is
one of the key language elements that enables Rust to reason strongly about pointer aliasing,
statically preventing crash bugs. Because of that, inherited mutability is preferred, and
interior mutability is something of a last resort. Since cell types enable mutation where it
would otherwise be disallowed though, there are occasions when interior mutability might be
appropriate, or even <em>must</em> be used, e.g.</p>
<ul>
<li>Introducing inherited mutability roots to shared types.</li>
<li>Implementation details of logically-immutable methods.</li>
<li>Mutating implementations of <code>Clone</code>.</li>
</ul>
<h2><a class="header" href="#introducing-inherited-mutability-roots-to-shared-types" id="introducing-inherited-mutability-roots-to-shared-types">Introducing inherited mutability roots to shared types</a></h2>
<p>Shared smart pointer types, including <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>, provide containers that can be
cloned and shared between multiple parties. Because the contained values may be
multiply-aliased, they can only be borrowed as shared references, not mutable references.
Without cells it would be impossible to mutate data inside of shared boxes at all!</p>
<p>It's very common then to put a <code>RefCell&lt;T&gt;</code> inside shared pointer types to reintroduce
mutability:</p>
<pre><code class="language-rust ignore">use std::collections::HashMap;
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let shared_map: Rc&lt;RefCell&lt;_&gt;&gt; = Rc::new(RefCell::new(HashMap::new()));
    shared_map.borrow_mut().insert(&quot;africa&quot;, 92388);
    shared_map.borrow_mut().insert(&quot;kyoto&quot;, 11837);
    shared_map.borrow_mut().insert(&quot;piccadilly&quot;, 11826);
    shared_map.borrow_mut().insert(&quot;marbles&quot;, 38);
}
</code></pre>
<p>Note that this example uses <code>Rc&lt;T&gt;</code> and not <code>Arc&lt;T&gt;</code>. <code>RefCell&lt;T&gt;</code>s are for single-threaded
scenarios. Consider using <code>Mutex&lt;T&gt;</code> if you need shared mutability in a multi-threaded
situation.</p>
<p>（訳）</p>
<p>共有可能な可変コンテナ．</p>
<p>一般的なRustの型は可変参照（<code>&amp;mut T</code>）を通してしか変更できませんが，<code>Cell&lt;T&gt;</code>型と<code>RefCell&lt;T&gt;</code>型
の値は共有参照（<code>&amp;T</code>）を通して変更される可能性があります．このことをもって<code>Cell&lt;T&gt;</code>と<code>RefCell&lt;T&gt;</code>
は「内部可変性」を持つと言います．これは他の普通の型が「継承可変性」を持つことと対照的です．</p>
<p>Cell型には<code>Cell&lt;T&gt;</code>と<code>RefCell&lt;T&gt;</code>の2種類があります．<code>Cell&lt;T&gt;</code>には内部の値を操作するための<code>get</code>
と<code>set</code>メソッドがあります．しかし<code>Cell&lt;T&gt;</code>は<code>Copy</code>を実装する型に対してしか機能しません．他の
型に対しては<code>RefCell&lt;T&gt;</code>を使用することで変更する前に書き込みロックを獲得する必要があります．</p>
<p><code>RefCell&lt;T&gt;</code>はRustのライフタイムを「動的借用」を実現するために使っています．動的借用とは一時的
かつ排他的な可変参照を得るための手段です．通常のRustの借用がコンパイル時に静的にチェックされる
のと違い，<code>RefCell&lt;T&gt;</code>による借用はランタイムにチェックされます．<code>RefCell&lt;T&gt;</code>の借用は動的であり，
実際には排他的でない可変な借用が発生する可能性があるからです．もしそうなったときはスレッドが
パニックします．</p>
<h1><a class="header" href="#どんなときに内部可変性を使うべきか" id="どんなときに内部可変性を使うべきか">どんなときに内部可変性を使うべきか</a></h1>
<p>値を変更するために排他的なアクセスを要求する継承可変性はRustの重要な言語機能の一つであり，
それによってポインタエイリアスを推論したりクラッシュバグを防いだりすることができています．
それゆえ継承可変性のほうが好まれ，内部可変性は最後の手段のようなものです．しかしCell型が
普通ではできない値の変更を行えるため，内部可変性がふさわしい，もしくは必要である場合が
あります．例えば次のようなときです．</p>
<ul>
<li>共有された型に継承可変性を持ち込むとき．</li>
<li>論理的に不変なメソッドの実装を行うとき．</li>
<li><code>Clone</code>の実装を変えるとき．</li>
</ul>
<h2><a class="header" href="#共有された型に継承可変性を持ち込むとき" id="共有された型に継承可変性を持ち込むとき">共有された型に継承可変性を持ち込むとき</a></h2>
<p><code>Rc&lt;T&gt;</code>や<code>Arc&lt;T&gt;</code>のような共有スマートポインタ型は，内側の値を複数の部分から利用可能にします．
内部の値は共有されているため，可変参照ではなく共有参照しか取得できません．Cell型なしでは
これらの内部の値を変化させることは全くできないのです！</p>
<p>可変性を得るために<code>RefCell&lt;T&gt;</code>をスマートポインタ型に入れることはとても一般的です：</p>
<pre><code class="language-rust ignore">use std::collections::HashMap;
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let shared_map: Rc&lt;RefCell&lt;_&gt;&gt; = Rc::new(RefCell::new(HashMap::new()));
    shared_map.borrow_mut().insert(&quot;africa&quot;, 92388);
    shared_map.borrow_mut().insert(&quot;kyoto&quot;, 11837);
    shared_map.borrow_mut().insert(&quot;piccadilly&quot;, 11826);
    shared_map.borrow_mut().insert(&quot;marbles&quot;, 38);
}
</code></pre>
<p>この例では<code>Arc&lt;T&gt;</code>ではなく<code>Rc&lt;T&gt;</code>を使っていることに注目してください．<code>RefCell&lt;T&gt;</code>は
単一スレッドで動作します．もしマルチスレッドで共有可変性が欲しい場合<code>Mutex&lt;T&gt;</code>を使って
ください．</p>
</blockquote>
<p>いやー，Rustのドキュメントは相変わらずマジ最高ですね．</p>
<p>とくに注目したいのはここです：</p>
<pre><code class="language-rust ignore">shared_map.borrow_mut().insert(&quot;africa&quot;, 92388);
</code></pre>
<p>もっというと<code>borrow_mut</code>ってやつです．RefCellから借用するときは明示的に
やらなくてはいけないようです．<code>.</code>が勝手にやってくれないのは不思議な
仕様ですね．まあやってみましょう：</p>
<pre><code class="language-rust ignore">pub fn push_front(&amp;mut self, elem: T) {
    let new_head = Node::new(elem);
    match self.head.take() {
        Some(old_head) =&gt; {
            old_head.borrow_mut().prev = Some(new_head.clone());
            new_head.borrow_mut().next = Some(old_head);
            self.head = Some(new_head);
        }
        None =&gt; {
            self.tail = Some(new_head.clone());
            self.head = Some(new_head);
        }
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

warning: field is never used: `elem`
  --&gt; src/fourth.rs:12:5
   |
12 |     elem: T,
   |     ^^^^^^^
   |
   = note: #[warn(dead_code)] on by default
</code></pre>
<p>ビルドしましたよ！またドキュメント勝ちしました．</p>
<h1><a class="header" href="#崩す" id="崩す">崩す</a></h1>
<p><code>pop_front</code>は<code>push_front</code>と同じ処理を逆に行えばよさそうです．やってみましょう：</p>
<pre><code class="language-rust ignore">pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
    // 古いheadをtakeする必要あり，これで-2
    self.head.take().map(|old_head| {                         // -1 old
        match old_head.borrow_mut().next.take() {
            Some(new_head) =&gt; {                               // -1 new
                // 空でないリスト
                new_head.borrow_mut().prev.take();            // -1 old
                self.head = Some(new_head);                   // +1 new
                // 計：-2 old, +0 new
            }
            None =&gt; {
                // 空リスト
                self.tail.take();                             // -1 old
                // 計：-2 old, (no new)
            }
        }
        old_head.elem
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0609]: no field `elem` on type `std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;`
  --&gt; src/fourth.rs:64:22
   |
64 |             old_head.elem
   |                      ^^^^ unknown field
</code></pre>
<p>アーッ．<em>RefCell</em>か．<code>borrow_mut</code>しなきゃいけないみたいですね...</p>
<pre><code class="language-rust ignore">pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.head.take().map(|old_head| {
        match old_head.borrow_mut().next.take() {
            Some(new_head) =&gt; {
                new_head.borrow_mut().prev.take();
                self.head = Some(new_head);
            }
            None =&gt; {
                self.tail.take();
            }
        }
        old_head.borrow_mut().elem
    })
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0507]: cannot move out of borrowed content
  --&gt; src/fourth.rs:64:13
   |
64 |             old_head.borrow_mut().elem
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot move out of borrowed content
</code></pre>
<p><em>ため息</em></p>
<blockquote>
<p>cannot move out of borrowed content</p>
</blockquote>
<p>フム...私達はBoxに<em>めちゃくちゃ</em>甘えていたみたいですね．<code>borrow_mut</code>は
<code>&amp;mut Node&lt;T&gt;</code>しか返さないのでムーブすることができません！</p>
<p><code>RefCell&lt;T&gt;</code>から<code>T</code>を返す何かが必要です．<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">ドキュメント</a>を見てみましょう：</p>
<blockquote>
<p><code>fn into_inner(self) -&gt; T</code></p>
<p>Consumes the RefCell, returning the wrapped value.</p>
</blockquote>
<p>これっぽいですね！</p>
<pre><code class="language-rust ignore">old_head.into_inner().elem
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0507]: cannot move out of an `Rc`
  --&gt; src/fourth.rs:64:13
   |
64 |             old_head.into_inner().elem
   |             ^^^^^^^^ cannot move out of an `Rc`
</code></pre>
<p>あークソが．<code>into_inner</code>はRefCellをムーブしようとしますが<code>Rc</code>の中にあるので
それはできません．前章でみた通り<code>Rc&lt;T&gt;</code>からは中身の共有参照しか取れません．
でもそりゃそうですよね．参照カウンタがついた値は共有されるためのものなのですから！</p>
<p>この問題を解決するためには，前回と同様<code>Rc::try_unwrap</code>を使います．参照カウントが
1ならRcから中身を取り出すメソッドです．</p>
<pre><code class="language-rust ignore">Rc::try_unwrap(old_head).unwrap().into_inner().elem
</code></pre>
<p><code>Rc::try_unwrap</code>は<code>Result&lt;T, Rc&lt;T&gt;&gt;</code>を返します．Resultは<code>Option</code>を汎化したような
もので，<code>None</code>にデータを入れられるようになったものです．この場合<code>None</code>
の代わりに返されるものは剥こうとした<code>Rc</code>です．今回は失敗の場合を考えないので
（プログラムを正しく書けていれば成功する<em>はず</em>です）単に<code>unwrap</code>します．</p>
<p>とにかく，次はどんなコンパイルエラーが出るか見てみましょう（準備はよろしいですか？
1個はあるはずです）．</p>
<pre><code class="language-text">&gt; cargo build

error[E0599]: no method named `unwrap` found for type `std::result::Result&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;, std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt;&gt;` in the current scope
  --&gt; src/fourth.rs:64:38
   |
64 |             Rc::try_unwrap(old_head).unwrap().into_inner().elem
   |                                      ^^^^^^
   |
   = note: the method `unwrap` exists but the following trait bounds were not satisfied:
           `std::rc::Rc&lt;std::cell::RefCell&lt;fourth::Node&lt;T&gt;&gt;&gt; : std::fmt::Debug`
</code></pre>
<p>ぐえー．Resultを<code>unwrap</code>するにはエラーとして渡される型をデバッグ出力できる必要が
あります．<code>RefCell&lt;T&gt;</code>は<code>T</code>が<code>Debug</code>を実装する場合のみデバッグ出力できますが，
<code>Node</code>は<code>Debug</code>を実装していませんでした．</p>
<p>Debugを実装するより，<code>ok</code>でResultをOptionに変換してしまう方がいいでしょう：</p>
<pre><code class="language-rust ignore">Rc::try_unwrap(old_head).ok().unwrap().into_inner().elem
</code></pre>
<p>頼む！！！</p>
<pre><code class="language-text">cargo build

</code></pre>
<p>や　っ　た　ぜ</p>
<p><em>フゥ</em></p>
<p>やりました．</p>
<p><code>push</code>と<code>pop</code>ができました．</p>
<p>はじめに作ったリストと実装した機能が同じなので，そっちからテストコードを
盗んできてテストしましょう：</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // 空のリストが動くことを確認
        assert_eq!(list.pop_front(), None);

        // リストの要素をつめる
        list.push_front(1);
        list.push_front(2);
        list.push_front(3);

        // 普通に要素を削除してみる
        assert_eq!(list.pop_front(), Some(3));
        assert_eq!(list.pop_front(), Some(2));

        // 何も壊れてないことを確認するためにもう一回push
        list.push_front(4);
        list.push_front(5);

        // 普通に要素を削除してみる
        assert_eq!(list.pop_front(), Some(5));
        assert_eq!(list.pop_front(), Some(4));

        // リストを出し切ったとき
        assert_eq!(list.pop_front(), Some(1));
        assert_eq!(list.pop_front(), None);
    }
}
</code></pre>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 9 tests
test first::test::basics ... ok
test fourth::test::basics ... ok
test second::test::iter_mut ... ok
test second::test::basics ... ok
test fifth::test::iter_mut ... ok
test third::test::basics ... ok
test second::test::iter ... ok
test third::test::iter ... ok
test second::test::into_iter ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p><em>はいバッチリ</em></p>
<p>これでリストから要素を取り除けるのでDropの実装に移れます．今回のDropはすこし
おもしろいことになっています．というのも，これまでDropを実装するに際し再帰が
起こらないようにがんばる必要がありましたが，今回はとにかく<em>何か</em>が起こるように
がんばる必要があります．</p>
<p><code>Rc</code>はサイクルを解放できません．サイクルがあるとそれぞれがそれぞれを生かし続けてしまします．
双方向リストは，何と小さいサイクルを大量に集めたものに他なりません！双方向リストをDropしようと
すると，端の2つのノードの参照カウントが1に減り...それ以上何も起こりません．ノードが1つだけ
なら上手くいきますが，リストには複数の要素を持つときにも動いてほしいですね．多分それは
私だけでしょう．</p>
<p>すでに見たように，要素を削除するのはちょっと面倒です．一番簡単な方法はNoneが出るまで
<code>pop</code>し続けることでしょう：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        while self.pop_front().is_some() {}
    }
}
</code></pre>
<pre><code class="language-text">cargo build

</code></pre>
<p>（実は可変なリストのときもこれと同じようにできたのですが，近道はちゃんと理解している人の
ためのものです！）</p>
<p>逆方向からの<code>push</code>と<code>pop</code>の実装について見ていってもいいですが，ただのコピペなので
後回しにします．先にもっと面白いものを見ていきましょう！</p>
<h1><a class="header" href="#peek-1" id="peek-1">Peek</a></h1>
<p>さて，<code>push</code>と<code>pop</code>を実装しました．私はちょっと感動してます．マジで．コンパイル時
の正確性があるというのは病みつきになりそうです．</p>
<p>簡単な<code>peek_front</code>でも実装して落ち着きましょう．いままでこのメソッドは簡単でしたし
今回も簡単なはずです．そうですよね？</p>
<p>そうですよね？</p>
<p>実際コピペで済みそうです！</p>
<pre><code class="language-rust ignore">pub fn peek_front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.as_ref().map(|node| {
        &amp;node.elem
    })
}
</code></pre>
<p>ちょっと待った．今回はこうです．</p>
<pre><code class="language-rust ignore">pub fn peek_front(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    self.head.as_ref().map(|node| {
        // BORROW!!!!
        &amp;node.borrow().elem
    })
}
</code></pre>
<p>どうよ．</p>
<pre><code class="language-text">cargo build

error[E0515]: cannot return value referencing temporary value
  --&gt; src/fourth.rs:66:13
   |
66 |             &amp;node.borrow().elem
   |             ^   ----------^^^^^
   |             |   |
   |             |   temporary value created here
   |             |
   |             returns a value referencing data owned by the current function
</code></pre>
<p>PC燃やしました．</p>
<p>片方向リストのときと同じロジックだろ．なんで違うんだ．なんで...</p>
<p>その答えはこの章から得られる教訓そのものです．その教訓とは，RefCellはあらゆるものに
悲しみをもたらす存在であるということです．これまでRefCellはただの困ったちゃんでしたが，
今悪夢と化しつつあります．</p>
<p>実際のところ何がどうなってるのでしょうか？それを理解するために<code>borrow</code>の定義をもう一度
見てみましょう：</p>
<pre><code class="language-rust ignore">fn borrow&lt;'a&gt;(&amp;'a self) -&gt; Ref&lt;'a, T&gt;
fn borrow_mut&lt;'a&gt;(&amp;'a self) -&gt; RefMut&lt;'a, T&gt;
</code></pre>
<p>設計の節でこのように書きました：</p>
<blockquote>
<p>RefCellはこの条件をコンパイルタイムではなくランタイムにチェックします．
もしルールが守られなければRefCellはパニックを起こし，プログラムは
クラッシュします．ところで，このRefとかRefMutとかいう型はなんでしょう？
これは基本的には借用のために使われるRcみたいなもので，これがスコープ外
に出るまでRefCellは借用されたままになります．<strong>これについては後で触れます．</strong></p>
</blockquote>
<p>今がその「後」です．</p>
<p><code>Ref</code>と<code>RefMut</code>はそれぞれ<code>Deref</code>と<code>DerefMut</code>を実装しています．これらは<code>&amp;T</code>，<code>&amp;mut T</code>
と<em>全く</em>同じ動作をするようになっているのですが，トレイトの実装上，戻り値のライフタイムは
RefCellではなくRefに紐付けられるようになっています．つまり戻り値の参照を使い続ける
間ずっとRefを生かしておかなくてはいけないということになります．</p>
<p>実はこれは整合性を取るためには必要なことです．Refがdropされれば，RefCellはもうそれを
借用しているものはないと判断してしまします．なのでもしRefより長く中の参照を持ち続け
ることができてしまったら，RefMutの排他性が損なわれRustの型システムを半壊させてしまいます．</p>
<p>結局どうしたらいいのでしょうか？ただ参照を返したいだけなのですが，参照を持ち続ける限り
Refを持ち続けなくてはいけません．そして<code>peek</code>がreturnしたとき<code>Ref</code>はスコープ外に
行ってしまいます．</p>
<p>😖</p>
<p>私が知る限りこれは手詰まりです．今回のような場合RefCellをカプセル化することはできないのです．</p>
<p>でも...もし実装の隠蔽を諦めたらどうでしょうか？Refを返したらどうなるのでしょう？</p>
<pre><code class="language-rust ignore">pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
    self.head.as_ref().map(|node| {
        node.borrow()
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0412]: cannot find type `Ref` in this scope
  --&gt; src/fourth.rs:63:40
   |
63 |     pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
   |                                        ^^^ not found in this scope
help: possible candidates are found in other modules, you can import them into scope
   |
1  | use core::cell::Ref;
   |
1  | use std::cell::Ref;
   |
</code></pre>
<p>ぶっは．importしなきゃいけませんね．</p>
<pre><code class="language-rust ignore">use std::cell::{Ref, RefCell};
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0308]: mismatched types
  --&gt; src/fourth.rs:64:9
   |
64 | /         self.head.as_ref().map(|node| {
65 | |             node.borrow()
66 | |         })
   | |__________^ expected type parameter, found struct `fourth::Node`
   |
   = note: expected type `std::option::Option&lt;std::cell::Ref&lt;'_, T&gt;&gt;`
              found type `std::option::Option&lt;std::cell::Ref&lt;'_, fourth::Node&lt;T&gt;&gt;&gt;`
</code></pre>
<p>うーん...確かに．<code>Ref&lt;Node&lt;T&gt;&gt;</code>を返していますが欲しいのは<code>Ref&lt;T&gt;</code>です．全てを諦めて
<code>Ref&lt;Node&lt;T&gt;&gt;</code>を返すというのも手ですし，<code>&amp;T</code>にだけアクセスできるような型で<code>Ref&lt;Node&lt;T&gt;&gt;</code>
をラップし事態を更に複雑化させるという手もあります．</p>
<p>どちらも<em>まあまあ</em>ダサいですね．</p>
<p>かわりにさらなる深淵を覗きましょう．<em>楽しもう</em>じゃないですか．楽しみの種はこの
<em>やべーやつ</em>です：</p>
<pre><code class="language-rust ignore">map&lt;U, F&gt;(orig: Ref&lt;'b, T&gt;, f: F) -&gt; Ref&lt;'b, U&gt;
    where F: FnOnce(&amp;T) -&gt; &amp;U,
          U: ?Sized
</code></pre>
<blockquote>
<p>Make a new Ref for a component of the borrowed data.</p>
</blockquote>
<p>そう，Option同様Refもmapできるのです．</p>
<p>どこかの誰かは<em>モナド</em>とか何とか言って興奮しているかと思いますが，私にはどうでもいい
ことです．あとこのメソッドはNothingのケースを持たないので厳密にはモナドではないと
思います．話がそれました．</p>
<p>このメソッドはイカすというその事実だけが重要です．<em>私にはこいつが必要です</em>．</p>
<pre><code class="language-rust ignore">pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
    self.head.as_ref().map(|node| {
        Ref::map(node.borrow(), |node| &amp;node.elem)
    })
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
</code></pre>
<p>やっっっった．</p>
<p>ちゃんと動いていることを，スタックのときに実装したテストを修正して確認しましょう．Ref
同士の比較はできないのでちょっと修正が必要です．</p>
<pre><code class="language-rust ignore">#[test]
fn peek() {
    let mut list = List::new();
    assert!(list.peek_front().is_none());
    list.push_front(1); list.push_front(2); list.push_front(3);

    assert_eq!(&amp;*list.peek_front().unwrap(), &amp;3);
}
</code></pre>
<pre><code>&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 10 tests
test first::test::basics ... ok
test fourth::test::basics ... ok
test second::test::basics ... ok
test fourth::test::peek ... ok
test second::test::iter_mut ... ok
test second::test::into_iter ... ok
test third::test::basics ... ok
test second::test::peek ... ok
test second::test::iter ... ok
test third::test::iter ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>やりました！</p>
<h1><a class="header" href="#対称的な操作" id="対称的な操作">対称的な操作</a></h1>
<p>それじゃあ対称なメソッドをやっつけてしまいましょう．</p>
<p>すべきことは文字列置換だけです．</p>
<pre><code class="language-text">tail &lt;-&gt; head
next &lt;-&gt; prev
front -&gt; back
</code></pre>
<p>あ，あとpeekの<code>_mut</code>バージョンもいりますね．</p>
<pre><code class="language-rust ignore">pub fn push_back(&amp;mut self, elem: T) {
    let new_tail = Node::new(elem);
    match self.tail.take() {
        Some(old_tail) =&gt; {
            old_tail.borrow_mut().next = Some(new_tail.clone());
            new_tail.borrow_mut().prev = Some(old_tail);
            self.tail = Some(new_tail);
        }
        None =&gt; {
            self.head = Some(new_tail.clone());
            self.tail = Some(new_tail);
        }
    }
}

pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.tail.take().map(|old_tail| {
        match old_tail.borrow_mut().prev.take() {
            Some(new_tail) =&gt; {
                new_tail.borrow_mut().next.take();
                self.tail = Some(new_tail);
            }
            None =&gt; {
                self.head.take();
            }
        }
        Rc::try_unwrap(old_tail).ok().unwrap().into_inner().elem
    })
}

pub fn peek_back(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
    self.tail.as_ref().map(|node| {
        Ref::map(node.borrow(), |node| &amp;node.elem)
    })
}

pub fn peek_back_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
    self.tail.as_ref().map(|node| {
        RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
    })
}

pub fn peek_front_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
    self.head.as_ref().map(|node| {
        RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
    })
}
</code></pre>
<p>そしてめっちゃテストを書きます：</p>
<pre><code class="language-rust ignore">#[test]
fn basics() {
    let mut list = List::new();

    // 空のリストが動くことを確認
    assert_eq!(list.pop_front(), None);

    // リストの要素をつめる
    list.push_front(1);
    list.push_front(2);
    list.push_front(3);

    // 普通に要素を削除してみる
    assert_eq!(list.pop_front(), Some(3));
    assert_eq!(list.pop_front(), Some(2));

    // 何も壊れてないことを確認するためにもう一回push
    list.push_front(4);
    list.push_front(5);

    // 普通に要素を削除してみる
    assert_eq!(list.pop_front(), Some(5));
    assert_eq!(list.pop_front(), Some(4));

    // リストを出し切ったとき
    assert_eq!(list.pop_front(), Some(1));
    assert_eq!(list.pop_front(), None);

    // ---- 逆順 -----

    // 空のリストが動くことを確認
    assert_eq!(list.pop_back(), None);

    // リストの要素をつめる
    list.push_back(1);
    list.push_back(2);
    list.push_back(3);

    // 普通に要素を削除してみる
    assert_eq!(list.pop_back(), Some(3));
    assert_eq!(list.pop_back(), Some(2));

    // 何も壊れてないことを確認するためにもう一回push
    list.push_back(4);
    list.push_back(5);

    // 普通に要素を削除してみる
    assert_eq!(list.pop_back(), Some(5));
    assert_eq!(list.pop_back(), Some(4));

    // リストを出し切ったとき
    assert_eq!(list.pop_back(), Some(1));
    assert_eq!(list.pop_back(), None);
}

#[test]
fn peek() {
    let mut list = List::new();
    assert!(list.peek_front().is_none());
    assert!(list.peek_back().is_none());
    assert!(list.peek_front_mut().is_none());
    assert!(list.peek_back_mut().is_none());

    list.push_front(1); list.push_front(2); list.push_front(3);

    assert_eq!(&amp;*list.peek_front().unwrap(), &amp;3);
    assert_eq!(&amp;mut *list.peek_front_mut().unwrap(), &amp;mut 3);
    assert_eq!(&amp;*list.peek_back().unwrap(), &amp;1);
    assert_eq!(&amp;mut *list.peek_back_mut().unwrap(), &amp;mut 1);
}
</code></pre>
<p>テスト漏れはあるでしょうか？多分あります．メソッド同士の組み合わせ空間は
めちゃくちゃ大きいです．でも少なくとも私達のコードは<em>明らかに間違ってる</em>
わけではないです．</p>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 10 tests
test first::test::basics ... ok
test fourth::test::basics ... ok
test second::test::basics ... ok
test fourth::test::peek ... ok
test second::test::iter ... ok
test third::test::iter ... ok
test second::test::into_iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>いいですね．コピペこそが最高のプログラミングです．</p>
<h1><a class="header" href="#イテレート" id="イテレート">イテレート</a></h1>
<p>この悪い子をイテレートしていきましょう．</p>
<h2><a class="header" href="#intoiter-1" id="intoiter-1">IntoIter</a></h2>
<p>いつものようにIntoIterが一番楽です．スタックでラップして<code>pop</code>を呼びましょう：</p>
<pre><code class="language-rust ignore">pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_front()
    }
}
</code></pre>
<p>でもちょっとおもしろいことが起こっています．前はリストをイテレートする「自然な」方向が
一意に決まっていましたが，両端キューには2つあります．もし逆方向にイテレートしたい人が
いたらどうしたらいいでしょうか？</p>
<p>じつはRustにはそのための<code>DoubleEndedIterator</code>トレイトがあります．DoubleEndedIterator
はIteratorを<em>継承</em>し（これは全てのDoubleEndedIteratorがIteratorsであることを意味します），
<code>next_back</code>というメソッドの実装を必要とします．このメソッドは<code>next</code>と全く同じシグネチャ
を持ちますが，逆側の要素を返すようになっています．DoubleEndedIteratorを使えば簡単に
イテレータを両端キューにして，イテレータが空になるまで前からでも後ろからでも要素を
取り出すことができます．</p>
<p><code>next_back</code>はDoubleEndedIteratorを使う人にとってそれほど重要なメソッドではありません．
それより，イテレータを逆順にして返す<code>rev</code>メソッドがあることのほうが重要です．この
メソッドのやっていることはとてもシンプルです．逆順になったイテレータで呼ばれる<code>next</code>は
代わりに<code>next_back</code>が呼ばれるというだけです．</p>
<p>なんにせよ私達のリストはすでに両端キューなので，これの実装は超簡単です：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_back()
    }
}
</code></pre>
<p>そしてテストします：</p>
<pre><code class="language-rust ignore">#[test]
fn into_iter() {
    let mut list = List::new();
    list.push_front(1); list.push_front(2); list.push_front(3);

    let mut iter = list.into_iter();
    assert_eq!(iter.next(), Some(3));
    assert_eq!(iter.next_back(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next_back(), None);
    assert_eq!(iter.next(), None);
}
</code></pre>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 11 tests
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test fourth::test::into_iter ... ok
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test third::test::iter ... ok
test third::test::basics ... ok
test second::test::into_iter ... ok
test second::test::peek ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured

</code></pre>
<p>イエーイ．</p>
<h2><a class="header" href="#iter-1" id="iter-1">Iter</a></h2>
<p>Iterはもうすこし厳しいです．またあの恐ろしい<code>Ref</code>と向き合わなくてはいけません！
Refのせいでこれまでのように<code>&amp;Node</code>を保持するわけにはいきません．代わりに<code>Ref&lt;Node&gt;</code>
を保持します：</p>
<pre><code class="language-rust ignore">pub struct Iter&lt;'a, T&gt;(Option&lt;Ref&lt;'a, Node&lt;T&gt;&gt;&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter(self.head.as_ref().map(|head| head.borrow()))
    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

</code></pre>
<p>ここまでは順調です．<code>next</code>の実装はちょっと難しいですが，これまでのIterMutの実装に
RefCellの狂気を添えた感じで行けると思います：</p>
<pre><code class="language-rust ignore">impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = Ref&lt;'a, T&gt;;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.take().map(|node_ref| {
            self.0 = node_ref.next.as_ref().map(|head| head.borrow());
            Ref::map(node_ref, |node| &amp;node.elem)
        })
    }
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0521]: borrowed data escapes outside of closure
   --&gt; src/fourth.rs:155:13
    |
153 |     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    |             --------- `self` is declared here, outside of the closure body
154 |         self.0.take().map(|node_ref| {
155 |             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
    |             ^^^^^^   -------- borrow is only valid in the closure body
    |             |
    |             reference to `node_ref` escapes the closure body here

error[E0505]: cannot move out of `node_ref` because it is borrowed
   --&gt; src/fourth.rs:156:22
    |
153 |     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    |             --------- lifetime `'1` appears in the type of `self`
154 |         self.0.take().map(|node_ref| {
155 |             self.0 = node_ref.next.as_ref().map(|head| head.borrow());
    |             ------   -------- borrow of `node_ref` occurs here
    |             |
    |             assignment requires that `node_ref` is borrowed for `'1`
156 |             Ref::map(node_ref, |node| &amp;node.elem)
    |                      ^^^^^^^^ move out of `node_ref` occurs here
</code></pre>
<p>クソが．</p>
<p><code>node_ref</code>のライフタイムが十分ではないようです．普通の参照と違って，Refをこんなふうに
分割することはできないようです．<code>head.borrow()</code>でとったRefは<code>node_ref</code>が生きている
間しか生きられませんが，私達は<code>Ref::map</code>で<code>node_ref</code>を捨てています．</p>
<p>偶然にも私がこれを書いているとき，私達が使いたい関数が2日前に安定化されました．つまり
あと数ヶ月でstableリリースに含まれることになります．なので最新のnightlyビルドを
使っていきましょう<sup class="footnote-reference"><a href="#1">1</a></sup>：</p>
<pre><code class="language-rust ignore">pub fn map_split&lt;U, V, F&gt;(orig: Ref&lt;'b, T&gt;, f: F) -&gt; (Ref&lt;'b, U&gt;, Ref&lt;'b, V&gt;) where
    F: FnOnce(&amp;T) -&gt; (&amp;U, &amp;V),
    U: ?Sized,
    V: ?Sized,
</code></pre>
<p>ウーッ．やってみましょう...</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    self.0.take().map(|node_ref| {
        let (next, elem) = Ref::map_split(node_ref, |node| {
            (&amp;node.next, &amp;node.elem)
        });

        self.0 = next.as_ref().map(|head| head.borrow());

        elem
    })
}
</code></pre>
<pre><code class="language-text">cargo build
   Compiling lists v0.1.0 (/Users/ABeingessner/dev/temp/lists)
error[E0521]: borrowed data escapes outside of closure
   --&gt; src/fourth.rs:159:13
    |
153 |     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    |             --------- `self` is declared here, outside of the closure body
...
159 |             self.0 = next.as_ref().map(|head| head.borrow());
    |             ^^^^^^   ---- borrow is only valid in the closure body
    |             |
    |             reference to `next` escapes the closure body here
</code></pre>
<p>えー．ライフタイムのつじつまを合わせるためにもう1回<code>Ref::Map</code>する必要がありますが，
私達が欲しいのは<code>Option&lt;Ref&gt;</code>であって<code>Ref::Map</code>から返る<code>Ref</code>ではありません．しかし
OptionをmapするにはRefの中を見る必要があります...</p>
<p><strong>（しばらく虚空を見つめる）</strong></p>
<p>??????</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
    self.0.take().map(|node_ref| {
        let (next, elem) = Ref::map_split(node_ref, |node| {
            (&amp;node.next, &amp;node.elem)
        });

        self.0 = if next.is_some() {
            Some(Ref::map(next, |next| &amp;**next.as_ref().unwrap()))
        } else {
            None
        };

        elem
    })
}
</code></pre>
<pre><code class="language-text">error[E0308]: mismatched types
   --&gt; src/fourth.rs:162:22
    |
162 |                 Some(Ref::map(next, |next| &amp;**next.as_ref().unwrap()))
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `fourth::Node`, found struct `std::cell::RefCell`
    |
    = note: expected type `std::cell::Ref&lt;'_, fourth::Node&lt;_&gt;&gt;`
               found type `std::cell::Ref&lt;'_, std::cell::RefCell&lt;fourth::Node&lt;_&gt;&gt;&gt;`
</code></pre>
<p>あーそうですね．RefCellが二重になっています．リストを深く探索すればするほどRefCellが
ネストしていってしまいます．複数の参照を一気にカウントしてくれるRefみたいなものが必要
です．リストの要素を解放したとき，それまでネストしてきた参照カウントを一気に1つづつ
デクリメントしてくれるような何か.............</p>
<p>もうなにか手が残っているとは思えません．終わりです．RefCellから離れて考えてみましょう．</p>
<p>Rcを使うというのはどうでしょう．参照を保持する必要なんかありませんよね？単にRcを
Cloneして所有権を管理させるのではダメでしょうか？</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Iter&lt;T&gt;(Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter(self.head.as_ref().map(|head| head.clone()))
    }
}

impl&lt;T&gt; Iterator for Iter&lt;T&gt; {
    type Item =
#}</code></pre></pre>
<p>えっと...待ってください，ここの型は何でしょう？<code>&amp;T</code>？<code>Ref&lt;T&gt;</code>？</p>
<p>だめです，どっちもうまくいきません...私達のIterはもはやライフタイムを持っていないのです！
<code>&amp;T</code>も<code>Ref&lt;T&gt;</code>も<code>next</code>する際にライフタイムが必要です．でもRcから出そうとするものは
Iteratorを借用します...ウッ，頭が...痛い...ぐあああああああああ</p>
<p>多分Rcを...mapして...<code>Rc&lt;T&gt;</code>にする？本当か？Rcのドキュメントを見る限りそういうことを
するメソッドはなさそうです．実際これをできるようにする<a href="https://crates.io/crates/owning_ref">クレート</a>を作った人がいます．</p>
<p>でも待ってください．かりに<em>それ</em>をやったとしてもさらに大きな問題に直面します．イテレータ
破壊という恐ろしい現象です．これまで私達はイテレータ破壊に対して完全に無敵でした．
なぜならIterはリストを借用するだけなので，それに変更を加えないからです．しかし，もし
IterがRcを返すならそれは借用に留まりません！これによってリストの利用者はポインタを持ち
続ける限り<code>push</code>や<code>pop</code>を呼べてしまえます！</p>
<p>おお神よ！いったいどうすればいいのですか！？</p>
<p>えっと，実はpushは無問題です．私達の見えている範囲よりリストの全体が大きくなる
だけです．大したことありません．</p>
<p>でも<code>pop</code>は話が別です．もし私達の知らないところでpopが行われても<em>まだ</em>大丈夫です．
もともとそのノードは私達の知らない所にあるので何も起こりません．しかし，もし私達
に見えているノードがpopされれば...全てがぶっ壊れます！具体的には<code>try_unwrap</code>の
結果を<code>unwrap</code>しようとしたときにpanicするでしょう．</p>
<p>これは実際かなりイケてます．リストを指すポインタを持つイテレータをいくらでも生成
できて，他が指しているノードを削除しようとしない限り<em>ともかく正常に動作する</em>のですから．
しかもそのような削除が発生したときにも，ダングリングポインタを生むこともなくしっかり
パニックしてくれるのです！</p>
<p>でもRcのマップをするためにイテレータ破壊に対処しなくてはいけないのはなんというか...
よくありません．私達は<code>Rc&lt;RefCell&gt;</code>に完膚無きまでに絶望させられました．面白いことに
いま私達は永続スタックのときの逆を体験しています．永続スタックのとき，私達はデータの
所有権を得ようと苦闘しましたが参照はほぼいつでも得ることができました．今回は所有権
を得るのは問題ありませんでしたが参照を貸し出すのに苦労しています．</p>
<p>とはいえ，公平に言って，私達が苦労している理由は実装の詳細を隠蔽し洗練されたAPIを
提供しようとしているからと言えるでしょう．もしNodeをどこにでも渡すようにすれば
すべてうまくやれたでしょう．</p>
<p>そうすればランタイムに同時に同じ要素が変更されないことを保証する並列IterMutすら
実装することができます！</p>
<p>本当にこの設計は内部のデータ構造を隠蔽するAPIに向いてませんね．内部可変性は安全な
<em>アプリケーション</em>を書くには適していますが，安全な<em>ライブラリ</em>を書くためには
それほど有用ではありません．</p>
<p>ともかくIterとIterMutは諦めます．実装できることはできますが，やりたくありません．</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>訳注：これは原文が書かれた当時の話で，当該関数はとっくにstableに入っています．したがってこのためにnightlyを使う必要はありません</p>
</div>
<h1><a class="header" href="#最終コード-3" id="最終コード-3">最終コード</a></h1>
<p>はい．これがRustで100%安全な双方向リストを実装するということです．悪夢のような体験でしたし，
できたリストは実装の詳細を晒している上いくつか基礎的な機能をがありません．</p>
<p>でも，確かにここに存在します．</p>
<p>あ，それと<code>Rc</code>と<code>RefCell</code>で大量の「不要な」ランタイムチェックを行っています．不要な
をカッコに入れたのは，実際には<em>本当に安全であること</em>を保証するために必要だからです．
実際いくつかのところでは必要<em>でした</em>．双方向リストはエイリアスと所有権がおそろしく
複雑に絡み合ったなにかでした！</p>
<p>でも私達はある程度やり遂げました．特に内部のデータ構造を晒すことを気にしないなら
上出来といえるでしょう．</p>
<p>ここからは，コインの裏側を見ていきたいと思います．<em>不安全</em>な実装によってあらゆるものの
制御を再び取り戻すのです．</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;
use std::cell::{Ref, RefMut, RefCell};

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
    prev: Link&lt;T&gt;,
}


impl&lt;T&gt; Node&lt;T&gt; {
    fn new(elem: T) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {
        Rc::new(RefCell::new(Node {
            elem: elem,
            prev: None,
            next: None,
        }))
    }
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }

    pub fn push_front(&amp;mut self, elem: T) {
        let new_head = Node::new(elem);
        match self.head.take() {
            Some(old_head) =&gt; {
                old_head.borrow_mut().prev = Some(new_head.clone());
                new_head.borrow_mut().next = Some(old_head);
                self.head = Some(new_head);
            }
            None =&gt; {
                self.tail = Some(new_head.clone());
                self.head = Some(new_head);
            }
        }
    }

    pub fn push_back(&amp;mut self, elem: T) {
        let new_tail = Node::new(elem);
        match self.tail.take() {
            Some(old_tail) =&gt; {
                old_tail.borrow_mut().next = Some(new_tail.clone());
                new_tail.borrow_mut().prev = Some(old_tail);
                self.tail = Some(new_tail);
            }
            None =&gt; {
                self.head = Some(new_tail.clone());
                self.tail = Some(new_tail);
            }
        }
    }

    pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.tail.take().map(|old_tail| {
            match old_tail.borrow_mut().prev.take() {
                Some(new_tail) =&gt; {
                    new_tail.borrow_mut().next.take();
                    self.tail = Some(new_tail);
                }
                None =&gt; {
                    self.head.take();
                }
            }
            Rc::try_unwrap(old_tail).ok().unwrap().into_inner().elem
        })
    }

    pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|old_head| {
            match old_head.borrow_mut().next.take() {
                Some(new_head) =&gt; {
                    new_head.borrow_mut().prev.take();
                    self.head = Some(new_head);
                }
                None =&gt; {
                    self.tail.take();
                }
            }
            Rc::try_unwrap(old_head).ok().unwrap().into_inner().elem
        })
    }

    pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
        self.head.as_ref().map(|node| {
            Ref::map(node.borrow(), |node| &amp;node.elem)
        })
    }

    pub fn peek_back(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
        self.tail.as_ref().map(|node| {
            Ref::map(node.borrow(), |node| &amp;node.elem)
        })
    }

    pub fn peek_back_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
        self.tail.as_ref().map(|node| {
            RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
        })
    }

    pub fn peek_front_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
        self.head.as_ref().map(|node| {
            RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
        })
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        while self.pop_front().is_some() {}
    }
}

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_front()
    }
}

impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_back()
    }
}

#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn basics() {
        let mut list = List::new();

        // 空のリストが動くことを確認
        assert_eq!(list.pop_front(), None);

        // リストの要素をつめる
        list.push_front(1);
        list.push_front(2);
        list.push_front(3);

        // 普通に要素を削除してみる
        assert_eq!(list.pop_front(), Some(3));
        assert_eq!(list.pop_front(), Some(2));

        // 何も壊れてないことを確認するためにもう一回push
        list.push_front(4);
        list.push_front(5);

        // 普通に要素を削除してみる
        assert_eq!(list.pop_front(), Some(5));
        assert_eq!(list.pop_front(), Some(4));

        // リストを出し切ったとき
        assert_eq!(list.pop_front(), Some(1));
        assert_eq!(list.pop_front(), None);

        // ---- 逆順 -----

        // 空のリストが動くことを確認
        assert_eq!(list.pop_back(), None);

        // リストの要素をつめる
        list.push_back(1);
        list.push_back(2);
        list.push_back(3);

        // 普通に要素を削除してみる
        assert_eq!(list.pop_back(), Some(3));
        assert_eq!(list.pop_back(), Some(2));

        // 何も壊れてないことを確認するためにもう一回push
        list.push_back(4);
        list.push_back(5);

        // 普通に要素を削除してみる
        assert_eq!(list.pop_back(), Some(5));
        assert_eq!(list.pop_back(), Some(4));

        // リストを出し切ったとき
        assert_eq!(list.pop_back(), Some(1));
        assert_eq!(list.pop_back(), None);
    }

    #[test]
    fn peek() {
        let mut list = List::new();
        assert!(list.peek_front().is_none());
        assert!(list.peek_back().is_none());
        assert!(list.peek_front_mut().is_none());
        assert!(list.peek_back_mut().is_none());

        list.push_front(1); list.push_front(2); list.push_front(3);

        assert_eq!(&amp;*list.peek_front().unwrap(), &amp;3);
        assert_eq!(&amp;mut *list.peek_front_mut().unwrap(), &amp;mut 3);
        assert_eq!(&amp;*list.peek_back().unwrap(), &amp;1);
        assert_eq!(&amp;mut *list.peek_back_mut().unwrap(), &amp;mut 1);
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push_front(1); list.push_front(2); list.push_front(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next_back(), Some(1));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next_back(), None);
        assert_eq!(iter.next(), None);
    }
}
#}</code></pre></pre>
<h1><a class="header" href="#不安全な片方向キュー" id="不安全な片方向キュー">不安全な片方向キュー</a></h1>
<p>えー，前回の参照カウントと内部可変性をつかったリストは少し私達の手に余りました．
もちろんRustではああいったことを一般的に想定しているわけではないですよね？
答えはYESでありNOです．RcとRefCellは簡単なものを扱う場合は素晴らしい型ですが
たまに扱いにくいことがあります．何が起こってるか隠蔽したい場合には特に．
もっといい方法があるはずです！</p>
<p>この章では片方向リストを再び扱い，その実装を通してちょっとだけ<em>生のポインタ</em>
と<em>不安全なRust</em>に触れます．</p>
<p><code>fifth.rs</code>という新しいファイルを作りましょう：</p>
<pre><code class="language-rust ignore">// in lib.rs

pub mod first;
pub mod second;
pub mod third;
pub mod fourth;
pub mod fifth;
</code></pre>
<p>連結リストの形を取る場合キューはほとんどスタックを拡張したものなので，ほとんどの
コードをsecond.rsを元にして書くことができます．でも，設計などの基本的な問題があるので
何もない状態から始めたいと思います．</p>
<h1><a class="header" href="#設計-2" id="設計-2">設計</a></h1>
<p>で，片方向キューとは何でしょうか？片方向スタックのとき，私達はリストの最後にpushして
同じ方向からpopしました．キューとスタックの違いはpopするのが逆側からであることだけです．
スタックのときはこんな感じでした：</p>
<pre><code class="language-text">input list:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)

stack push X:
[Some(ptr)] -&gt; (X, Some(ptr)) -&gt; (A, Some(ptr)) -&gt; (B, None)

stack pop:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)
</code></pre>
<p>キューを作るには，popとpushのどちらでリストの最後の要素を操作するか決めなくては
いけません．片方向リストなのでどっちにしろ同程度の計算量になります．</p>
<p><code>push</code>を最後にするなら，リストを<code>None</code>が出るまでたどり新しい要素が入ったSomeに
入れ替えます．</p>
<pre><code class="language-text">input list:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)

flipped push X:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, Some(ptr)) -&gt; (X, None)
</code></pre>
<p><code>pop</code>を最後にするなら，リストを<code>None</code>が出る<em>直前まで</em>たどり<code>take</code>します．</p>
<pre><code class="language-text">input list:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, Some(ptr)) -&gt; (X, None)

flipped pop:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)
</code></pre>
<p>これのどちらかをやって完成でもいいですが，これではお粗末です！どちらにせよリストの
<em>全体</em>をたどる必要があります．正しいインターフェースを提供しているのでキューの実装としては
これでいいという人もいるでしょう．ですが私はパフォーマンスを保証することもインターフェースの
一部であると考えます．漸近的境界がどうのという話ではなく<em>速い</em>か<em>遅い</em>かです．キューは
popとpushが速いことを保証するデータ構造であり，リスト全体をたどる操作は明らかに速くは
ありません．</p>
<p>ひとつの重要な視点は，同じことを何回も繰り返してリソースを無駄にしていることです．
この操作を記憶できないでしょうか？なんと，できます！リストの末尾へのポインタを持ち，
そこに直接行けばいいのです！</p>
<p>リストの末尾を使う操作は<code>push</code>と<code>pop</code>のどちらかで大丈夫です．<code>pop</code>で使う場合
末尾へのポインタを逆向きにたどる必要がありますが，片方向リストの性質上これを
効率的に行うのは困難です．<code>push</code>で使うようにすれば，popするときはリストの先頭の
ポインタを順方向にたどればいいので楽ですね．</p>
<p>試してみましょう：</p>
<pre><code class="language-rust ignore">use std::mem;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Link&lt;T&gt;, // NEW!
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // pushしたときのnextは常にNone
            next: None,
        });

        // 古いtailを新しいtailに更新
        let old_tail = mem::replace(&amp;mut self.tail, Some(new_tail));

        match old_tail {
            Some(mut old_tail) =&gt; {
                // もしtailがすでにあれば新しいtailを入れる
                old_tail.next = Some(new_tail);
            }
            None =&gt; {
                // そうでなければheadに入れる
                self.head = Some(new_tail);
            }
        }
    }
}
</code></pre>
<p>この手の操作を書くのはかなり慣れてきていると思うので実装のペースをすこし上げていきます．
とはいえ上のようなコードを一発で書き上げる必要はありません．今まであったような
トライアンドエラーをとばして書いているだけです．実際私はこのコードを書くにあたって
めちゃくちゃ間違えてます．私が出したエラーを全部見せていたら<code>mut</code>や<code>;</code>の書き忘れが
あまりにも多く教本の体をなしていないでしょう．でも心配しないでください．これから
<em>別の</em>エラーメッセージを沢山見ることになります！</p>
<pre><code class="language-text">&gt; cargo build

error[E0382]: use of moved value: `new_tail`
  --&gt; src/fifth.rs:38:38
   |
26 |         let new_tail = Box::new(Node {
   |             -------- move occurs because `new_tail` has type `std::boxed::Box&lt;fifth::Node&lt;T&gt;&gt;`, which does not implement the `Copy` trait
...
33 |         let old_tail = mem::replace(&amp;mut self.tail, Some(new_tail));
   |                                                          -------- value moved here
...
38 |                 old_tail.next = Some(new_tail);
   |                                      ^^^^^^^^ value used here after move
</code></pre>
<p>クソ！</p>
<blockquote>
<p>use of moved value: <code>new_tail</code></p>
</blockquote>
<p>BoxはCopyを実装していないので2箇所に入れることはできません．更に重要なことはBoxは
中身の所有権を持つのでBoxがdropされたとき中身を解放しようとする点です．もしこの
実装がコンパイルしてしまったら<code>push</code>するたびにリストの末尾を2回解放することになります．
というか実際私達のコードはpushのたびにold_tailを解放しています！ギエー！🙀</p>
<p>OK，でも私達は所有権を持たないポインタがなにか知っています．ふつうの参照です！</p>
<pre><code class="language-rust ignore">pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Option&lt;&amp;mut Node&lt;T&gt;&gt;, // NEW!
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // pushしたときのnextは常にNone
            next: None,
        });

        // Put the box in the right place, and then grab a reference to its Node
        let new_tail = match self.tail.take() {
            Some(old_tail) =&gt; {
                // もしtailがすでにあれば新しいtailを入れる
                old_tail.next = Some(new_tail);
                old_tail.next.as_mut().map(|node| &amp;mut **node)
            }
            None =&gt; {
                // そうでなければheadに入れる
                self.head = Some(new_tail);
                self.head.as_mut().map(|node| &amp;mut **node)
            }
        };

        self.tail = new_tail;
    }
}
</code></pre>
<p>特にトリッキーなことはしていません．基本的な発想はさっきと同じで，違いは暗黙のリターン
を使ってnew_tailを作っていることくらいです．</p>
<pre><code class="language-text">&gt; cargo build

error[E0106]: missing lifetime specifier
 --&gt; src/fifth.rs:3:18
  |
3 |     tail: Option&lt;&amp;mut Node&lt;T&gt;&gt;, // NEW!
  |                  ^ expected lifetime parameter
</code></pre>
<p>ああそうでした．ライフタイムを与えなくてはいけません．うーん...ここのライフタイムは
何でしょう？えっと，これってIterMutに似てますよね？IterMutと同じことをして，
パラメータ名は<code>'a</code>を使いましょう：</p>
<pre><code class="language-rust ignore">pub struct List&lt;'a, T&gt; {
    head: Link&lt;T&gt;,
    tail: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;, // NEW!
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;'a, T&gt; List&lt;'a, T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // pushしたときのnextは常にNone
            next: None,
        });

        // Put the box in the right place, and then grab a reference to its Node
        let new_tail = match self.tail.take() {
            Some(old_tail) =&gt; {
                // もしtailがすでにあれば新しいtailを入れる
                old_tail.next = Some(new_tail);
                old_tail.next.as_mut().map(|node| &amp;mut **node)
            }
            None =&gt; {
                // そうでなければheadに入れる
                self.head = Some(new_tail);
                self.head.as_mut().map(|node| &amp;mut **node)
            }
        };

        self.tail = new_tail;
    }
}
</code></pre>
<pre><code class="language-text">cargo build

error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements
  --&gt; src/fifth.rs:35:27
   |
35 |                 self.head.as_mut().map(|node| &amp;mut **node)
   |                           ^^^^^^
   |
note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 18:5...
  --&gt; src/fifth.rs:18:5
   |
18 | /     pub fn push(&amp;mut self, elem: T) {
19 | |         let new_tail = Box::new(Node {
20 | |             elem: elem,
21 | |             // pushしたときのnextは常にNone
...  |
39 | |         self.tail = new_tail;
40 | |     }
   | |_____^
note: ...so that reference does not outlive borrowed content
  --&gt; src/fifth.rs:35:17
   |
35 |                 self.head.as_mut().map(|node| &amp;mut **node)
   |                 ^^^^^^^^^
note: but, the lifetime must be valid for the lifetime 'a as defined on the impl at 13:6...
  --&gt; src/fifth.rs:13:6
   |
13 | impl&lt;'a, T&gt; List&lt;'a, T&gt; {
   |      ^^
   = note: ...so that the expression is assignable:
           expected std::option::Option&lt;&amp;'a mut fifth::Node&lt;T&gt;&gt;
              found std::option::Option&lt;&amp;mut fifth::Node&lt;T&gt;&gt;


</code></pre>
<p>わー，これはずいぶん詳細なエラーメッセージですね．これはすこし憂慮すべきエラーです．
というのもこれによると私達はかなりめちゃくちゃなことをやっているからです．興味深いのは
部分です：</p>
<blockquote>
<p>the lifetime must be valid for the lifetime <code>'a</code> as defined on the impl</p>
</blockquote>
<p><code>self</code>を借用しているわけですが，コンパイラは少なくとも<code>'a</code>だけ生存して欲しがっています．
では<code>self</code>が実際<code>'a</code>だけ生存すると示せばどうでしょう...？</p>
<pre><code class="language-rust ignore">    pub fn push(&amp;'a mut self, elem: T) {
</code></pre>
<pre><code class="language-text">cargo build

warning: field is never used: `elem`
 --&gt; src/fifth.rs:9:5
  |
9 |     elem: T,
  |     ^^^^^^^
  |
  = note: #[warn(dead_code)] on by default
</code></pre>
<p>見てください，動きました！やった！</p>
<p><code>pop</code>も同様に実装します：</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;'a mut self) -&gt; Option&lt;T&gt; {
    // リストの今のheadを取る
    self.head.take().map(|head| {
        let head = *head;
        self.head = head.next;

        // もし`head`がなかったらtailに`None`を入れる
        if self.head.is_none() {
            self.tail = None;
        }

        head.elem
    })
}
</code></pre>
<p>そしてちゃちゃっとテストを書いてしまいましょう：</p>
<pre><code class="language-rust ignore">mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // 空のリストが動くことを確認
        assert_eq!(list.pop(), None);

        // リストの要素をつめる
        list.push(1);
        list.push(2);
        list.push(3);

        // 普通に要素を削除してみる
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // 何も壊れてないことを確認するためにもう一回push
        list.push(4);
        list.push(5);

        // 普通に要素を削除してみる
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // リストを出し切ったとき
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);
    }
}
</code></pre>
<pre><code class="language-text">cargo test

error[E0499]: cannot borrow `list` as mutable more than once at a time
  --&gt; src/fifth.rs:68:9
   |
65 |         assert_eq!(list.pop(), None);
   |                    ---- first mutable borrow occurs here
...
68 |         list.push(1);
   |         ^^^^
   |         |
   |         second mutable borrow occurs here
   |         first borrow later used here

error[E0499]: cannot borrow `list` as mutable more than once at a time
  --&gt; src/fifth.rs:69:9
   |
65 |         assert_eq!(list.pop(), None);
   |                    ---- first mutable borrow occurs here
...
69 |         list.push(2);
   |         ^^^^
   |         |
   |         second mutable borrow occurs here
   |         first borrow later used here

error[E0499]: cannot borrow `list` as mutable more than once at a time
  --&gt; src/fifth.rs:70:9
   |
65 |         assert_eq!(list.pop(), None);
   |                    ---- first mutable borrow occurs here
...
70 |         list.push(3);
   |         ^^^^
   |         |
   |         second mutable borrow occurs here
   |         first borrow later used here


....

** まだまだあるエラー **

....

error: aborting due to 11 previous errors
</code></pre>
<p>🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀🙀</p>
<p>何ということでしょう．</p>
<p>コンパイラは悪くありません．私達はたった今Rustの原罪<sup class="footnote-reference"><a href="#1">1</a></sup>を犯したのです．私達は
自分への参照を<em>自分自身の中に</em>持ってしまいました．<code>push</code>と<code>pop</code>の実装では
なんとかRustを言いくるめることができました（それができたのは衝撃的でしたが）．
私はRustが<code>push</code>と<code>pop</code>を見た時点では参照がそれ自身の中にあるかどうか
分からなかったんだと思いますが--というか，Rustにはそういう概念がありません．
自分自身への参照が動作しないのは単なる現象に過ぎず，根本的な問題ではありません．</p>
<p>私達のリストは使おうとした途端全てが空中分解します．<code>push</code>や<code>pop</code>を呼んだ瞬間
リストは自分への参照を持ち，<em>詰みます</em>．自分自身を借用しているのです．</p>
<p><code>pop</code>の実装を見るとなぜこれが危険であるかわかります：</p>
<pre><code class="language-rust ignore">// ...
if self.head.is_none() {
    self.tail = None;
}
</code></pre>
<p>もし私達がこれを忘れたらどうなっていたでしょう？リストのtailは<em>リストから除外された
ノード</em>を指すことになります．リストから除外されたノードのメモリは解放され，Rust
が防いでくれるはずのダングリングポインタが生まれてしまいます！</p>
<p>Rustはたしかにそういう危険から私達を守ってくれているのです．ただかなり...
<strong>回りくどい</strong>やりかたですが．</p>
<p>ではどうしたらいいでしょうか？また<code>Rc&lt;RefCell&gt;&gt;</code>地獄に戻る？</p>
<p>だめです．勘弁してください．</p>
<p>かわりに敷かれたレールを外れて<em>生のポインタ</em>を使います．私達のリストはこんな感じに
なるでしょう：</p>
<pre><code class="language-rust ignore">pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: *mut Node&lt;T&gt;, // DANGER DANGER
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}
</code></pre>
<p>そしてこれが全てです．もうクソ雑魚参照カウント付動的借用チェックには頼りません！
本物の，過酷な，未検査の，ポインタを使います．</p>
<p>みなさん，C言語でいきましょう．いつも，いつでもCで．</p>
<p>私はここに帰ってきました．もう準備はできてます．</p>
<p>Hello, <code>unsafe</code>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>訳注：Lust（色欲）とかかっている</p>
</div>
<h1><a class="header" href="#unsafe-rust" id="unsafe-rust">Unsafe Rust</a></h1>
<p>これは深刻で，大きく，複雑で，危険な話題です．あまりに深刻なので
私はもう一冊<a href="https://doc.rust-jp.rs/rust-nomicon-ja/">これについての本</a>を書きました．</p>
<p>とにもかくにも，<em>どんな</em>言語も他の言語を呼び出した途端不安全になります．呼び出したCが適当に
悪いことをするのを許さなくてはなりませんから．Javaも，Pythonも，Rubyも，Haskellも...
FFI（Foreign Function Interface）の前ではあらゆる言語が不安全になります．</p>
<p>Rustはこの事実を受け止めるために自分自身を2つの言語に分けました．安全なRustと，不安全な
Rustです．ここまで私達は安全なRustだけを扱ってきました．安全なRustは100%完全に安全です...
不安全なRustにFFIできることを除いて．</p>
<p>不安全なRustは安全なRustの機能をすべて持っており，それに加えていくつか<em>追加の</em>，C言語に
取り付いている恐ろしい未定義動作を引き起こすような，野蛮かつ不安全な操作が行なえます．</p>
<p>繰り返しになりますが，この話題はたくさんの興味深い内容を含みます．私は本当にこの話題に
深入りしたくありません（実はしたいです．というかしました．<a href="https://doc.rust-jp.rs/rust-nomicon-ja/">こちらを読んでください</a>）．
でも大丈夫です．私達のリストを実装する上では深入りする必要はありません．</p>
<p>主に使う不安全アイテムは<em>生ポインタ</em>です．生ポインタとは，基本的にはCのポインタです．
エイリアスルールを持たず，ライフタイムを持たず，nullポインタにもダングリングポインタにも
なり得る，未初期化のメモリ領域を指すこともでき，整数型と互換性があり，キャストして別の型を
指すようにもできます．可変性がほしい？キャストしましょう．あまりにもなんでもできるため，
あまりにもよくぶっ壊れます．</p>
<p>生ポインタは悪いやつであり，正直関わらないほうが幸せな人生を送れます．しかし不幸にも
私達はおぞましい連結リストを書きたいのです．つまり私達は不安全な生ポインタを使わなくては
いけません．</p>
<p>生ポインタには二種類あります．<code>*const T</code>と<code>*mut T</code>です．これはそれぞれCでいうところの
<code>const T*</code>と<code>T*</code>ですが，実はCでどう扱われているかはそれほど重要ではありません．
<code>*const T</code>は参照外しによって<code>&amp;T</code>にしか変換できませんが，これは変数の可変性と同じ感じで
誤った使い方を防ぐためです．要はたいていの場合，まず<code>*const</code>を<code>*mut</code>にキャストする
必要があるということです．たとえポインタの指す値を変える権限がなくてもよくないことが
起こりうるのです．</p>
<p>まあなんにせよ書いていくうちに慣れてくるでしょう．とりあえず<code>*mut T == &amp;unchecked mut T</code>
と考えてください！</p>
<h1><a class="header" href="#基本-1" id="基本-1">基本</a></h1>
<p>はい，では基本に立ち返りましょう．どうやってリストを初期化したら
よいでしょうか？</p>
<p>前回はこうしました：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: None }
    }
}
</code></pre>
<p>しかしもはや<code>tail</code>にOptionを使っていません：</p>
<pre><code class="language-text">&gt; cargo build

error[E0308]: mismatched types
  --&gt; src/fifth.rs:15:34
   |
15 |         List { head: None, tail: None }
   |                                  ^^^^ expected *-ptr, found enum `std::option::Option`
   |
   = note: expected type `*mut fifth::Node&lt;T&gt;`
              found type `std::option::Option&lt;_&gt;`
</code></pre>
<p>Optionを使うこともできるにはできますが，Boxと違って<code>*mut</code>はnullになり得ます．つまり
ヌルポインタ最適化の恩恵を受けられないのです．なので，Optionを使う代わりに<code>null</code>で
Noneを表すことにしましょう．</p>
<p>ではヌルポインタを代入するにはどうすればいいでしょうか？いくつかやり方はありますが，
私は<code>std::ptr::null_mut()</code>を使うのが好きです．<code>0 as *mut _</code>を使う手もありますが
ちょっと汚く見えます．</p>
<pre><code class="language-rust ignore">use std::ptr;

// defns...

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: ptr::null_mut() }
    }
}
</code></pre>
<pre><code class="language-text">cargo build

warning: field is never used: `head`
 --&gt; src/fifth.rs:4:5
  |
4 |     head: Link&lt;T&gt;,
  |     ^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `tail`
 --&gt; src/fifth.rs:5:5
  |
5 |     tail: *mut Node&lt;T&gt;,
  |     ^^^^^^^^^^^^^^^^^^

warning: field is never used: `elem`
  --&gt; src/fifth.rs:11:5
   |
11 |     elem: T,
   |     ^^^^^^^

warning: field is never used: `head`
  --&gt; src/fifth.rs:12:5
   |
12 |     head: Link&lt;T&gt;,
   |     ^^^^^^^^^^^^^
</code></pre>
<p>黙ってろコンパイラ，今から使うから．</p>
<p>はい，ではもう一度<code>push</code>を実装していきましょう．今回は挿入したあとに<code>Option&lt;&amp;mut Node&lt;T&gt;&gt;</code>
を取るのではなく，Boxの中にある<code>*mut Node&lt;T&gt;</code>をそのまま取ります．これがうまくいくのは
Boxを移動しても中身のメモリアドレスは変わらないからですね．もちろんこれは不安全な操作です．
もしBoxをdropしてしまったら私達は解放されたメモリを指すポインタを持つことになります．</p>
<p>どうすれば普通のポインタから生ポインタを作れるのでしょうか？Coercionです！
もし変数が生ポインタとして宣言されていれば，普通の参照は生ポインタになることを強制
（Coerce）されます：</p>
<pre><code class="language-rust ignore">let raw_tail: *mut _ = &amp;mut *new_tail;
</code></pre>
<p>これで必要なものは揃いました．前回の参照を使ったバージョンとだいたい同じ感じに
書けます：</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: T) {
    let mut new_tail = Box::new(Node {
        elem: elem,
        next: None,
    });

    let raw_tail: *mut _ = &amp;mut *new_tail;

    // .is_nullはnullかどうかをチェックします
    // Noneかどうかをチェックするのと同じ役割です
    if !self.tail.is_null() {
        // もしtailがすでにあれば新しいtailを入れる
        self.tail.next = Some(new_tail);
    } else {
        // そうでなければheadに入れる
        self.head = Some(new_tail);
    }

    self.tail = raw_tail;
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0609]: no field `next` on type `*mut fifth::Node&lt;T&gt;`
  --&gt; src/fifth.rs:31:23
   |
31 |             self.tail.next = Some(new_tail);
   |             ----------^^^^
   |             |
   |             help: `self.tail` is a raw pointer; try dereferencing it: `(*self.tail).next`
</code></pre>
<p>は？Nodeのポインタを持ってるのに<code>next</code>をとれないの？</p>
<p>Rustは生ポインタを使い出すとちょっと嫌なヤツになります．生ポインタの中身にアクセス
するとき，不安全な操作だと言って手動で参照外しをすることを強制してくるのです．では
そのようにやってみましょう：</p>
<pre><code class="language-rust ignore">*self.tail.next = Some(new_tail);
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0609]: no field `next` on type `*mut fifth::Node&lt;T&gt;`
  --&gt; src/fifth.rs:31:23
   |
31 |             *self.tail.next = Some(new_tail);
   |             -----------^^^^
   |             |
   |             help: `self.tail` is a raw pointer; try dereferencing it: `(*self.tail).next`
</code></pre>
<p>うううううオペレータの優先順を考えなくてはいけませんでした．</p>
<pre><code class="language-rust ignore">(*self.tail).next = Some(new_tail);
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block
  --&gt; src/fifth.rs:31:13
   |
31 |             (*self.tail).next = Some(new_tail);
   |             ^^^^^^^^^^^^^^^^^ dereference of raw pointer
   |
   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior
</code></pre>
<p>こんな難しいわけないだろ．</p>
<p>不安全なRustは安全なRustにとってFFIみたいなものだと言ったことを覚えていますか？えっと，
私達はコンパイラにどこでFFIしているか明示する必要があります．方法は二つです．一つ目は
関数全体を不安全にすることで，そうすると関数は不安全なRustに属し，<code>unsafe</code>なところ
からしか呼べなくなります．これはあまり良くありません．私達はリストを使う分には安全に
したいのですから．二つ目は関数内に<code>unsafe</code>ブロックを書き，FFIの境界を切ることです．
この場合関数自体は安全なままです．後者でいってみましょう：</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: T) {
    let mut new_tail = Box::new(Node {
        elem: elem,
        next: None,
    });

    let raw_tail: *mut _ = &amp;mut *new_tail;

    // .is_nullはnullかどうかをチェックします
    // Noneかどうかをチェックするのと同じ役割です
    if !self.tail.is_null() {
        // もしtailがすでにあれば新しいtailを入れる
        unsafe {
            (*self.tail).next = Some(new_tail);
        }
    } else {
        // そうでなければheadに入れる
        self.head = Some(new_tail);
    }

    self.tail = raw_tail;
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
warning: field is never used: `elem`
  --&gt; src/fifth.rs:11:5
   |
11 |     elem: T,
   |     ^^^^^^^
   |
   = note: #[warn(dead_code)] on by default
</code></pre>
<p>イエーイ！</p>
<p>他のいろんなところでも生ポインタを扱っているのにここ<em>しか</em>unsafeにしなくていいのは
ちょっとおもしろいですね．何が起こっているのでしょうか？</p>
<p><code>unsafe</code>のことになるとRustはかなり仕切りたがり屋であるようです．私達は安全なRustのほうが
自信があるので当然できるだけそっちを使いたいわけですが，Rustはそれを達成するために
不安全な部分が最小になるような境界を注意深く引いてくれるのです．私達が生ポインタを
使っている他の部分はポインタに<em>代入している</em>か，nullかどうかチェックしているだけである
ことに注目してください．</p>
<p>もし参照を外さないのであれば，<em>生ポインタは完全に安全です</em>．ただ整数を読んだり書いたり
しているだけです！生ポインタで問題が起きるのは参照を外すときだけなので，Rustはその
操作<em>だけ</em>を不安全だと言い，ほかは安全な操作として扱うのです．</p>
<p>超．衒学的．でも技術的には正しいですね．</p>
<p>しかしこれは興味深い問題を生みます．もし<code>unsafe</code>ブロックを区切っても，その中の
状態はunsafeブロックの外部に依存します．もしかしたら関数の外にすら依存するかも
しれません！</p>
<p>わたしはこれをunsafe<em>汚染</em>と呼んでいます．<code>unsafe</code>を使うや否やモジュール全体が
不安全に汚染されてしまうのです．コードの不変性が不安全さを支えて持ちこたえられる
ためには，全てが正しく実装されている必要があります．</p>
<p>この汚染は<em>プライバシー</em>によって食い止められます．私達のモジュール外からはstructの
フィールドは操作できないので私達以外の誰もそれらの内部状態を好き勝手することはできません．
私達のAPIをどんなふうに組み合わせも安全であり，かつ外部から操作できる範囲がちゃんと
正しく決められている限り，私達のコードは安全です！そして本当にこれはFFIと何も
変わりません．PythonのライブラリがCを呼び出していようと，安全なインターフェースを
提供している限り誰も気にしません．</p>
<p>ともかく<code>pop</code>にいきましょう．参照をつかうバージョンとほぼ一緒です：</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.head.take().map(|head| {
        let head = *head;
        self.head = head.next;

        if self.head.is_none() {
            self.tail = ptr::null_mut();
        }

        head.elem
    })
}
</code></pre>
<p>またしても安全とはステートフルであることを示すケースに遭遇しました．もしこの関数で
tailのポインタをnullにするのを忘れても，すぐにはなんの問題も現れません．しかし
そのあと<code>push</code>するとダングリングポインタになっているtailに書き込んでしまいます！</p>
<p>テストしていきましょう：</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // 空のリストが動くことを確認
        assert_eq!(list.pop(), None);

        // リストの要素をつめる
        list.push(1);
        list.push(2);
        list.push(3);

        // 普通に要素を削除してみる
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // 何も壊れてないことを確認するためにもう一回push
        list.push(4);
        list.push(5);

        // 普通に要素を削除してみる
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // リストを出し切ったとき
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);

        // リストを出し切ってもポインタが破壊されてないことを確認
        list.push(6);
        list.push(7);

        // 普通に要素を削除してみる
        assert_eq!(list.pop(), Some(6));
        assert_eq!(list.pop(), Some(7));
        assert_eq!(list.pop(), None);
    }
}
</code></pre>
<p>これはスタックのテストそのままですが，<code>pop</code>が逆順に出てくることを期待している点が違います．
また，最後に<code>pop</code>が空振りしたときもポインタが壊れていないか確認するケースを追加しています．</p>
<pre><code class="language-text">cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 12 tests
test fifth::test::basics ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test fourth::test::into_iter ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>大金星！</p>
<h1><a class="header" href="#その他のゴミ" id="その他のゴミ">その他のゴミ</a></h1>
<p><code>push</code>と<code>pop</code>が書けたので後はスタックのときと完全に同じです．リストの長さを変える
操作だけが末尾ポインタのことを気にかければよいのです．</p>
<p>というわけで二番目のリストから全てをパクってきましょう（テストでpopが逆順に出てくる
ことを期待するよう変えることを忘れないでください）：</p>
<pre><code class="language-rust ignore">// ...

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

pub struct IterMut&lt;'a, T&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}




impl&lt;T&gt; List&lt;T&gt; {
    // ...

    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| {
            &amp;node.elem
        })
    }

    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        self.head.as_mut().map(|node| {
            &amp;mut node.elem
        })
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;'_, T&gt; {
        IterMut { next: self.head.as_mut().map(|node| &amp;mut **node) }
    }
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop()
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &amp;**node);
            &amp;node.elem
        })
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.take().map(|node| {
            self.next = node.next.as_mut().map(|node| &amp;mut **node);
            &amp;mut node.elem
        })
    }
}





#[cfg(test)]
mod test {
    // ...

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(1));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;1));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter_mut();
        assert_eq!(iter.next(), Some(&amp;mut 1));
        assert_eq!(iter.next(), Some(&amp;mut 2));
        assert_eq!(iter.next(), Some(&amp;mut 3));
        assert_eq!(iter.next(), None);
    }
}

</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 15 tests
test fifth::test::into_iter ... ok
test fifth::test::basics ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test first::test::basics ... ok
test fourth::test::basics ... ok
test fourth::test::into_iter ... ok
test fourth::test::peek ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test second::test::peek ... ok
test third::test::basics ... ok
test third::test::iter ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>コピペプログラミングに感謝を．</p>
<p>一瞬IntoIterが動かないんじゃないかと思いましたがいい感じに逆順にpopできていましたね！</p>
<h1><a class="header" href="#最終コード-4" id="最終コード-4">最終コード</a></h1>
<p>さて，不安全にほんのちょびっと触っただけで安全なキューから線形時間の性能向上が
得られました．しかもほとんどすべてのロジックを安全なスタックから再利用することが
できています！</p>
<p>そしてRcとかRefCellとかの狂ったものを書かずに済んでいます．</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ptr;

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: *mut Node&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail: ptr::null_mut() }
    }

    pub fn push(&amp;mut self, elem: T) {
        let mut new_tail = Box::new(Node {
            elem: elem,
            next: None,
        });

        let raw_tail: *mut _ = &amp;mut *new_tail;

        if !self.tail.is_null() {
            unsafe {
                (*self.tail).next = Some(new_tail);
            }
        } else {
            self.head = Some(new_tail);
        }

        self.tail = raw_tail;
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|head| {
            let head = *head;
            self.head = head.next;

            if self.head.is_none() {
                self.tail = ptr::null_mut();
            }

            head.elem
        })
    }

    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| {
            &amp;node.elem
        })
    }

    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        self.head.as_mut().map(|node| {
            &amp;mut node.elem
        })
    }

    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }

    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;**node) }
    }

    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;'_, T&gt; {
        IterMut { next: self.head.as_mut().map(|node| &amp;mut **node) }
    }
}

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;,
}

pub struct IterMut&lt;'a, T&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}

impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop()
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &amp;**node);
            &amp;node.elem
        })
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.take().map(|node| {
            self.next = node.next.as_mut().map(|node| &amp;mut **node);
            &amp;mut node.elem
        })
    }
}

#[cfg(test)]
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // 空のリストが動くことを確認
        assert_eq!(list.pop(), None);

        // リストの要素をつめる
        list.push(1);
        list.push(2);
        list.push(3);

        // 普通に要素を削除してみる
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // 何も壊れてないことを確認するためにもう一回push
        list.push(4);
        list.push(5);

        // 普通に要素を削除してみる
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // リストを出し切ったとき
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);

        // リストを出し切ってもポインタが破壊されてないことを確認
        list.push(6);
        list.push(7);

        // 普通に要素を削除してみる
        assert_eq!(list.pop(), Some(6));
        assert_eq!(list.pop(), Some(7));
        assert_eq!(list.pop(), None);
    }

    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(1));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;1));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter_mut();
        assert_eq!(iter.next(), Some(&amp;mut 1));
        assert_eq!(iter.next(), Some(&amp;mut 2));
        assert_eq!(iter.next(), Some(&amp;mut 3));
        assert_eq!(iter.next(), None);
    }
}
#}</code></pre></pre>
<h1><a class="header" href="#まあまあなメモリ不安全双方向両端キュー" id="まあまあなメモリ不安全双方向両端キュー">まあまあなメモリ不安全双方向両端キュー</a></h1>
<p>いや，これを書き忘れてました！これはそんなにためになるものではありません．</p>
<p>もし本当にこれを実装したければ<a href="https://doc.rust-jp.rs/rust-nomicon-ja/">裏本</a>と<a href="https://github.com/rust-lang/rust/blob/master/src/liballoc/collections/linked_list.rs">std::collections::LinkedList</a>のソースを読んでください！</p>
<h1><a class="header" href="#アホなリストたち" id="アホなリストたち">アホなリストたち</a></h1>
<p>よし，これで終わりです．全てのリストを実装しました．</p>
<p>ワハハハハハハ</p>
<p>まだです</p>
<p>リストはいくらでもあります．</p>
<p>この章はほかの馬鹿げたリストと，それらがRustでどう扱われるかについての更新中<sup class="footnote-reference"><a href="#1">1</a></sup>の
ドキュメントです．</p>
<ol>
<li>
<p><a href="infinity-double-single.html">二重片方向リスト</a></p>
</li>
<li>
<p>TODO: BList?</p>
</li>
<li>
<p>TODO: SkipList?</p>
</li>
<li>
<p>TODO: std::channel? -- That's like another whole chapter. Or 3.</p>
</li>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>訳注：途絶えてます</p>
</div>
</ol>
<h1><a class="header" href="#二重片方向リスト" id="二重片方向リスト">二重片方向リスト</a></h1>
<p>複雑な所有権を持っていたため双方向リストでは苦戦しました．というのも，どのノードも
他のノードの所有権をはっきりと持っていたわけではなかったからです．しかし私達は
連結リストに対する先入観があったために苦戦していたとも言えます．つまり，
すべてのリンクが同じ方向に行くことを想定していたのです．</p>
<p>そうではなく，リストを半分に分割して，片方を右回り，もう片方を左回りのリストに
することもできます：</p>
<pre><code class="language-rust ignore">// lib.rs
// ...
pub mod silly1;     // NEW!
</code></pre>
<pre><code class="language-rust ignore">// silly1.rs
use second::List as Stack;

struct List&lt;T&gt; {
    left: Stack&lt;T&gt;,
    right: Stack&lt;T&gt;,
}
</code></pre>
<p>これでただのスタックではなく汎用リストになりました．好きな方のスタックにpush
することでどちらの方向にもリストを伸ばすことができます．さらに片方の端から
もう片方の端にNodeを移すことでリストを渡ることもできます．不要なメモリ割り当てを
避けるために，安全なスタックのソースをコピーして実装の詳細を得ます：</p>
<pre><code class="language-rust ignore">pub struct Stack&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; Stack&lt;T&gt; {
    pub fn new() -&gt; Self {
        Stack { head: None }
    }

    pub fn push(&amp;mut self, elem: T) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head.take(),
        });

        self.head = Some(new_node);
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|node| {
            let node = *node;
            self.head = node.next;
            node.elem
        })
    }

    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| {
            &amp;node.elem
        })
    }

    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        self.head.as_mut().map(|node| {
            &amp;mut node.elem
        })
    }
}

impl&lt;T&gt; Drop for Stack&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut cur_link = self.head.take();
        while let Some(mut boxed_node) = cur_link {
            cur_link = boxed_node.next.take();
        }
    }
}
</code></pre>
<p>そして<code>push</code>と<code>pop</code>をちょっと作り変えます：</p>
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: T) {
    let new_node = Box::new(Node {
        elem: elem,
        next: None,
    });

    self.push_node(new_node);
}

fn push_node(&amp;mut self, mut node: Box&lt;Node&lt;T&gt;&gt;) {
    node.next = self.head.take();
    self.head = Some(node);
}

pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.pop_node().map(|node| {
        node.elem
    })
}

fn pop_node(&amp;mut self) -&gt; Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt; {
    self.head.take().map(|mut node| {
        self.head = node.next.take();
        node
    })
}
</code></pre>
<p>これでListのコンストラクタを書けます：</p>
<pre><code class="language-rust ignore">pub struct List&lt;T&gt; {
    left: Stack&lt;T&gt;,
    right: Stack&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    fn new() -&gt; Self {
        List { left: Stack::new(), right: Stack::new() }
    }
}
</code></pre>
<p>いつもの：</p>
<pre><code class="language-rust ignore">pub fn push_left(&amp;mut self, elem: T) { self.left.push(elem) }
pub fn push_right(&amp;mut self, elem: T) { self.right.push(elem) }
pub fn pop_left(&amp;mut self) -&gt; Option&lt;T&gt; { self.left.pop() }
pub fn pop_right(&amp;mut self) -&gt; Option&lt;T&gt; { self.right.pop() }
pub fn peek_left(&amp;self) -&gt; Option&lt;&amp;T&gt; { self.left.peek() }
pub fn peek_right(&amp;self) -&gt; Option&lt;&amp;T&gt; { self.right.peek() }
pub fn peek_left_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; { self.left.peek_mut() }
pub fn peek_right_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; { self.right.peek_mut() }
</code></pre>
<p>一番面白いのはリストを渡ることができることです！</p>
<pre><code class="language-rust ignore">pub fn go_left(&amp;mut self) -&gt; bool {
    self.left.pop_node().map(|node| {
        self.right.push_node(node);
    }).is_some()
}

pub fn go_right(&amp;mut self) -&gt; bool {
    self.right.pop_node().map(|node| {
        self.left.push_node(node);
    }).is_some()
}
</code></pre>
<p>本当に移動ができたかどうかを示すためにbooleanを返しています．テストしてみましょう：</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod test {
    use super::List;

    #[test]
    fn walk_aboot() {
        let mut list = List::new();             // [_]

        list.push_left(0);                      // [0,_]
        list.push_right(1);                     // [0, _, 1]
        assert_eq!(list.peek_left(), Some(&amp;0));
        assert_eq!(list.peek_right(), Some(&amp;1));

        list.push_left(2);                      // [0, 2, _, 1]
        list.push_left(3);                      // [0, 2, 3, _, 1]
        list.push_right(4);                     // [0, 2, 3, _, 4, 1]

        while list.go_left() {}                 // [_, 0, 2, 3, 4, 1]

        assert_eq!(list.pop_left(), None);
        assert_eq!(list.pop_right(), Some(0));  // [_, 2, 3, 4, 1]
        assert_eq!(list.pop_right(), Some(2));  // [_, 3, 4, 1]

        list.push_left(5);                      // [5, _, 3, 4, 1]
        assert_eq!(list.pop_right(), Some(3));  // [5, _, 4, 1]
        assert_eq!(list.pop_left(), Some(5));   // [_, 4, 1]
        assert_eq!(list.pop_right(), Some(4));  // [_, 1]
        assert_eq!(list.pop_right(), Some(1));  // [_]

        assert_eq!(list.pop_right(), None);
        assert_eq!(list.pop_left(), None);

    }
}
</code></pre>
<pre><code class="language-text">&gt; cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 16 tests
test fifth::test::into_iter ... ok
test fifth::test::basics ... ok
test fifth::test::iter ... ok
test fifth::test::iter_mut ... ok
test fourth::test::into_iter ... ok
test fourth::test::basics ... ok
test fourth::test::peek ... ok
test first::test::basics ... ok
test second::test::into_iter ... ok
test second::test::basics ... ok
test second::test::iter ... ok
test second::test::iter_mut ... ok
test third::test::basics ... ok
test third::test::iter ... ok
test second::test::peek ... ok
test silly1::test::walk_aboot ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>これは<em>指差し</em>データ構造の極端な例です．指差しデータ構造は，データのどこかを指で
指し続けることで指からの距離に比例した時間で操作を行えるようにするデータ構造です．</p>
<p>指の周りのノードに対しては高速で操作が行なえますが，指から離れたところに対しては
リストを渡っていかなくてはいけません．要素を片側からもう片側に移すことで永続的に
渡る事もできますし，<code>&amp;mut</code>を使って一時的に移動することもできます．しかし<code>&amp;mut</code>は
リストを逆にたどることはできないのに対し，指を使えばそれが出来るのです！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
